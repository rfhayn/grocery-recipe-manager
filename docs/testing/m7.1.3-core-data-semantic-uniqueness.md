# Technical Design â€“ Core Data Semantic Uniqueness & Repository Architecture

**Milestone:** M7.1.3  
**Audience:** Developers (Claude)  
**Purpose:** Detailed implementation blueprint  

---

# 1. Overview

This document describes:

- Semantic identity implementation  
- Repository patterns  
- Code-level examples for three entity types:
  - Category  
  - WeeklyList  
  - IngredientTemplate  
- Dedup migration strategy  
- UI hardening  

This pattern should be applied across the domain.

---

# 2. Data Model Changes

## 2.1 Category
Add properties:

normalizedName: String (non-optional)
updatedAt: Date

Unique constraint:

normalizedName

## 2.2 WeeklyList
Add:

weekIdentifier: String (non-optional)
createdAt: Date
updatedAt: Date

## 2.3 IngredientTemplate
Add:

canonicalName: String (non-optional)
createdAt: Date
updatedAt: Date

Unique constraint:

canonicalName

---

# 3. Repository Implementations

Below are real implementations to paste into `Services/`.

---

# 3.1 CategoryRepository

## Protocol
```swift
protocol CategoryRepository {
    func getOrCreateCategory(displayName: String,
                             in context: NSManagedObjectContext) throws -> Category

    func fetchAllCategories(in context: NSManagedObjectContext) throws -> [Category]
}

Implementation

final class DefaultCategoryRepository: CategoryRepository {

    func getOrCreateCategory(displayName: String,
                             in context: NSManagedObjectContext) throws -> Category {
        let normalized = normalize(displayName)

        let request: NSFetchRequest<Category> = Category.fetchRequest()
        request.predicate = NSPredicate(format: "normalizedName == %@", normalized)
        request.fetchLimit = 1

        if let existing = try context.fetch(request).first {
            return existing
        }

        let category = Category(context: context)
        category.id = UUID()
        category.displayName = displayName
        category.normalizedName = normalized
        category.updatedAt = Date()

        return category
    }

    func fetchAllCategories(in context: NSManagedObjectContext) throws -> [Category] {
        let request: NSFetchRequest<Category> = Category.fetchRequest()
        request.sortDescriptors = [NSSortDescriptor(key: "displayName", ascending: true)]
        return try context.fetch(request)
    }

    private func normalize(_ name: String) -> String {
        name.trimmingCharacters(in: .whitespacesAndNewlines).lowercased()
    }
}

3.2 WeeklyListRepository

Protocol

protocol WeeklyListRepository {
    func getOrCreateWeeklyList(for date: Date,
                               in context: NSManagedObjectContext) throws -> WeeklyList

    func fetchWeeklyList(for date: Date,
                         in context: NSManagedObjectContext) throws -> WeeklyList?
}

Implementation

final class DefaultWeeklyListRepository: WeeklyListRepository {

    func getOrCreateWeeklyList(for date: Date,
                               in context: NSManagedObjectContext) throws -> WeeklyList {
        let weekId = weekIdentifier(for: date)

        if let existing = try fetchWeeklyList(for: date, in: context) {
            return existing
        }

        let list = WeeklyList(context: context)
        list.id = UUID()
        list.name = "Weekly Shopping"
        list.weekIdentifier = weekId
        list.createdAt = Date()

        return list
    }

    func fetchWeeklyList(for date: Date,
                         in context: NSManagedObjectContext) throws -> WeeklyList? {
        let weekId = weekIdentifier(for: date)

        let request: NSFetchRequest<WeeklyList> = WeeklyList.fetchRequest()
        request.predicate = NSPredicate(format: "weekIdentifier == %@", weekId)
        request.fetchLimit = 1

        return try context.fetch(request).first
    }

    private func weekIdentifier(for date: Date) -> String {
        let calendar = Calendar(identifier: .iso8601)
        let weekOfYear = calendar.component(.weekOfYear, from: date)
        let yearForWeek = calendar.component(.yearForWeekOfYear, from: date)
        return "\(yearForWeek)-W\(weekOfYear)"
    }
}

3.3 IngredientTemplateService

Protocol

protocol IngredientTemplateService {
    func getOrCreateTemplate(name: String,
                             in context: NSManagedObjectContext) throws -> IngredientTemplate

    func fetchTemplate(canonicalName: String,
                       in context: NSManagedObjectContext) throws -> IngredientTemplate?
}

Implementation

final class DefaultIngredientTemplateService: IngredientTemplateService {

    func getOrCreateTemplate(name: String,
                             in context: NSManagedObjectContext) throws -> IngredientTemplate {
        let canonical = normalize(name)

        if let existing = try fetchTemplate(canonicalName: canonical, in: context) {
            return existing
        }

        let template = IngredientTemplate(context: context)
        template.id = UUID()
        template.name = name
        template.canonicalName = canonical
        template.createdAt = Date()
        template.updatedAt = Date()

        return template
    }

    func fetchTemplate(canonicalName: String,
                       in context: NSManagedObjectContext) throws -> IngredientTemplate? {
        let request: NSFetchRequest<IngredientTemplate> = IngredientTemplate.fetchRequest()
        request.predicate = NSPredicate(format: "canonicalName == %@", canonicalName)
        request.fetchLimit = 1

        return try context.fetch(request).first
    }

    private func normalize(_ name: String) -> String {
        name.trimmingCharacters(in: .whitespacesAndNewlines).lowercased()
    }
}

4. Deduplication Migration

CategoryDeduplicator

final class CategoryDeduplicator {
    func run(in context: NSManagedObjectContext) throws {
        let request: NSFetchRequest<Category> = Category.fetchRequest()
        let all = try context.fetch(request)

        let groups = Dictionary(grouping: all, by: { $0.normalizedName })

        for (_, group) in groups where group.count > 1 {
            let keeper = group.first!
            for dup in group.dropFirst() {
                context.delete(dup)
            }
        }

        if context.hasChanges {
            try context.save()
        }
    }
}

IngredientTemplateDeduplicator

final class IngredientTemplateDeduplicator {
    func run(in context: NSManagedObjectContext) throws {
        let request: NSFetchRequest<IngredientTemplate> = IngredientTemplate.fetchRequest()
        let all = try context.fetch(request)

        let groups = Dictionary(grouping: all, by: { $0.canonicalName })

        for (_, group) in groups where group.count > 1 {
            guard let keeper = group.first else { continue }
            let duplicates = group.dropFirst()

            for dup in duplicates {
                if let ingredients = dup.ingredients as? Set<Ingredient> {
                    for ingredient in ingredients {
                        ingredient.template = keeper
                    }
                }
                context.delete(dup)
            }
        }

        if context.hasChanges {
            try context.save()
        }
    }
}

5. UI Safety

Replace:

Dictionary(uniqueKeysWithValues: ...)

With grouping:

let grouped = Dictionary(grouping: categories, by: \.displayName)
let uniqueCategories = grouped.mapValues { $0.first! }

6. Wiring Repositories

In PersistenceController:

categoryRepository = DefaultCategoryRepository()
ingredientTemplateService = DefaultIngredientTemplateService()
weeklyListRepository = DefaultWeeklyListRepository()

container.viewContext.mergePolicy = NSMergeByPropertyObjectTrumpMergePolicy
container.viewContext.automaticallyMergesChangesFromParent = true

7. Implementation Checklist (Claude)
	1.	Add semantic fields
	2.	Add constraints
	3.	Write repositories
	4.	Replace direct instantiation
	5.	Implement dedup
	6.	Harden UI
	7.	Test across devices

---

# ------------------------------------------------------------
# ðŸ“„ **DOCUMENT 4 â€” Claude Implementation Prompt**  
### **Filename:** `Claude-implementation-prompt.md`
# ------------------------------------------------------------

```markdown
# Claude Implementation Prompt â€“ M7.1.3 Sync Integrity

Claude, your task is to implement the M7.1.3 CloudKit Sync Integrity milestone.

You must use these three documents:

1. **ADR-008-core-data-cloudkit-sync.md**  
2. **PRD-m7.1.3-cloudkit-sync-integrity.md**  
3. **TDD-core-data-semantic-uniqueness.md**

---

# 1. Your Responsibilities

### 1. Add Semantic Identity Fields
Modify the Core Data model to include:

- `Category.normalizedName`
- `IngredientTemplate.canonicalName`
- `WeeklyList.weekIdentifier`
- `MealPlan.slotKey` (optional this milestone)
- Ownership metadata for sharing:
  - `ownerUserRecordID`
  - `sharingScope`

### 2. Add Unique Constraints
Create Core Data uniqueness constraints for:

- Category.normalizedName  
- IngredientTemplate.canonicalName  

### 3. Implement Repositories
Build:

- `DefaultCategoryRepository`
- `DefaultWeeklyListRepository`
- `DefaultIngredientTemplateService`

Each must:

- Compute semantic keys  
- Query before create  
- Guarantee uniqueness  
- Prevent direct NSManagedObject creation from anywhere else  

### 4. Replace All Direct Instantiation
Search for and eliminate:

Category(context:)
IngredientTemplate(context:)
WeeklyList(context:)

All creation must go through repositories.

### 5. Add Dedup Migration
Implement:

- CategoryDeduplicator  
- IngredientTemplateDeduplicator  

Run them on startup after model version upgrade.

### 6. Harden the UI  
Replace dictionary initializers requiring unique keys with grouping logic.

### 7. Testing  
Follow the PRD test plan:

- Category duplication prevention  
- IngredientTemplate dedup  
- WeeklyList uniqueness  
- Legacy dedup migration  
- UI stability  

---

# 8. Deliverables

You must provide:

- Code diffs  
- Updated Core Data model  
- Verification screenshots/logs showing no duplicates remain  
- Confirmation that all PRD acceptance criteria are met  

---