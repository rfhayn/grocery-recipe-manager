# Product Requirements Document: M7.1.3 CloudKit Sync Integrity

**Milestone:** M7.1.3 CloudKit Sync Integrity - Semantic Uniqueness Architecture  
**Version:** 4.1 - Production-Ready Implementation with Comprehensive ADRs  
**Date:** December 10, 2024  
**Status:** üöÄ READY TO START  
**Estimated Time:** 11-15 hours (implementation + testing + comprehensive documentation)

---

## üìã EXECUTIVE SUMMARY

### **Original Problem**
M7.1.3 testing revealed fundamental architectural issue: CloudKit Core Data creates duplicate entities across devices when multiple devices create semantically identical objects (same Category name, same IngredientTemplate name, etc.). This breaks the app with crashes like "Fatal error: Duplicate values for key: 'Produce'".

### **Root Cause**
CloudKit Core Data has no concept of "semantic uniqueness" - it only knows UUID uniqueness. Two devices creating `Category(displayName: "Produce")` results in two different CloudKit records with different UUIDs but identical semantic meaning.

### **Solution Scope (Simplified - No Pre-Existing Data)**
Since forager has no production users or real data, we can implement clean architecture without complex deduplication:

**Core Entities with Semantic Uniqueness:**
- **Category:** One category per normalized name (e.g., "Produce")
- **IngredientTemplate:** One template per canonical name (e.g., "basil")
- **PlannedMeal:** One meal per date/mealType slot (e.g., "2024-12-10-breakfast")

**User-Assisted Detection:**
- **Recipe:** Detect duplicate titles, let user decide (allow intentional duplicates)

**Allow Duplicates by Design:**
- **WeeklyList:** Just a list container, no uniqueness constraint
- **MealPlan:** Week-long plan container, no uniqueness constraint
- **GroceryListItem:** Duplicates intentional (consolidation in UI layer)

### **Key Architectural Improvements**
‚úÖ **Two-stage migration** (add fields ‚Üí populate ‚Üí add constraints)  
‚úÖ **Canonical normalization helpers** (consistent everywhere)  
‚úÖ **Repository pattern** (prevents duplicates going forward)  
‚úÖ **Field standardization** (name ‚Üí displayName across all entities)  
‚úÖ **PlannedMeal.mealType** (new field for slot protection)  
‚úÖ **Calendar.current timezone** (meals stay on calendar dates)  
‚úÖ **No deduplication needed** (clean slate implementation)

### **Key Decisions**
‚úÖ No timeline pressure ‚Üí Build it right  
‚úÖ No real production data ‚Üí Skip deduplication, single clean migration  
‚úÖ Two devices available ‚Üí Comprehensive testing possible  
‚úÖ Repository pattern prevents future duplicates  
‚úÖ User control over Recipe duplicates (detect + assist)

---

## üéØ GOALS & SUCCESS CRITERIA

### **Primary Goals**
1. **Zero Duplicate Creation:** Repository pattern prevents creating semantic duplicates
2. **Field Standardization:** Rename `name` ‚Üí `displayName` for consistency
3. **User Control:** Recipe duplicates flagged for user resolution, not auto-prevented
4. **Slot Protection:** PlannedMeal enforces one meal per date/mealType
5. **Clean Architecture:** No technical debt from quick fixes

### **Success Criteria**
- ‚úÖ Multi-device sync creates zero duplicate Categories
- ‚úÖ Multi-device sync creates zero duplicate IngredientTemplates
- ‚úÖ PlannedMeals enforce one meal per slot (date + mealType)
- ‚úÖ Recipe save shows detection dialog if similar recipe exists
- ‚úÖ WeeklyLists, MealPlans, GroceryListItems allow duplicates as designed
- ‚úÖ All entities use `displayName` consistently
- ‚úÖ All tests pass with 2 physical devices
- ‚úÖ Zero regressions to M1-M7.1.2 features

### **Performance Targets**
- Semantic key lookups: < 0.001s (Core Data indexed queries)
- Repository get-or-create: < 0.01s
- CloudKit sync with semantic uniqueness: < 5s
- UI operations: < 0.5s (existing standard)

---

## üèóÔ∏è ARCHITECTURE OVERVIEW

### **Three-Layer Pattern**

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ Layer 1: Core Data Model - Semantic Keys               ‚îÇ
‚îÇ - normalizedName, canonicalName, slotKey               ‚îÇ
‚îÇ - Uniqueness constraints on semantic keys              ‚îÇ
‚îÇ - Indexed for fast lookups                             ‚îÇ
‚îÇ - displayName standardized across all entities         ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                         ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ Layer 2: Repository Pattern - Get-or-Create            ‚îÇ
‚îÇ - ALWAYS query by semantic key first                   ‚îÇ
‚îÇ - Only create if genuinely doesn't exist               ‚îÇ
‚îÇ - Guaranteed single source of truth                    ‚îÇ
‚îÇ - Canonical normalization helpers                      ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                         ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ Layer 3: Application Layer - Use Repositories          ‚îÇ
‚îÇ - NO direct Category(context:) instantiation           ‚îÇ
‚îÇ - NO direct IngredientTemplate(context:) creation      ‚îÇ
‚îÇ - ALL creation goes through repositories               ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### **Semantic Key Strategy by Entity**

| Entity | Semantic Key | Strategy | Constraint | Changed in v4 |
|--------|-------------|----------|------------|---------------|
| **Category** | `normalizedName` | Repository get-or-create | ‚úÖ Unique | Field rename |
| **IngredientTemplate** | `canonicalName` | Repository get-or-create | ‚úÖ Unique | Field rename |
| **PlannedMeal** | `slotKey` | Repository get-or-create | ‚úÖ Unique | ‚≠ê **NEW** |
| **Recipe** | `titleKey` | Detect + user dialog | ‚ùå No constraint | Field rename |
| **WeeklyList** | None | Direct creation | ‚ùå No constraint | ‚≠ê **SIMPLIFIED** |
| **MealPlan** | None | Direct creation | ‚ùå No constraint | ‚≠ê **CLARIFIED** |
| **GroceryListItem** | None | Direct creation | ‚ùå No constraint | No change |

---

## üîß TWO-STAGE MIGRATION STRATEGY

### **Why Two Stages?**

**Problem:** Adding uniqueness constraints before all devices sync can cause `NSConstraintConflictError`:
1. Device A upgrades ‚Üí adds constraints
2. Device B hasn't upgraded yet ‚Üí still creating duplicates
3. CloudKit syncs Device B's duplicates to Device A
4. Device A crashes with constraint conflict

**Solution:** Separate field addition from constraint enforcement.

---

### **Stage A: Add Semantic Keys (Model Version 2)**

**Goal:** Introduce fields, populate them, let all devices sync clean data

**Core Data Model Changes:**
```swift
// Add fields as OPTIONAL (allow nil during transition)
Category {
    displayName: String?        // Renamed from 'name'
    normalizedName: String?     // NEW - semantic key (lowercase, trimmed)
    updatedAt: Date?           // NEW - conflict resolution
}

IngredientTemplate {
    displayName: String?        // Renamed from 'name'
    canonicalName: String?      // NEW - semantic key (normalized)
    createdAt: Date?           // NEW - tracking
    updatedAt: Date?           // NEW - conflict resolution
}

PlannedMeal {
    date: Date?
    mealType: String?          // NEW - "breakfast", "lunch", "dinner", "snack"
    slotKey: String?           // NEW - semantic key (date + mealType)
    createdAt: Date?           // NEW - tracking
    recipe: Recipe?
    mealPlan: MealPlan?
}

Recipe {
    displayName: String?        // Renamed from 'title'
    titleKey: String?          // NEW - for duplicate detection (normalized)
    createdAt: Date?           // Existing (ensure present)
}

// NO constraints yet - just field addition
```

**Migration Code:**
```swift
// In Persistence.swift
private func performStageAMigration(in context: NSManagedObjectContext) {
    let stageAKey = "M7.1.3.StageA.Completed"
    guard !UserDefaults.standard.bool(forKey: stageAKey) else {
        print("‚ÑπÔ∏è Stage A migration already completed")
        return
    }
    
    print("üöÄ Stage A: Adding semantic key fields...")
    
    // Populate semantic keys for existing entities
    populateCategorySemanticKeys(in: context)
    populateIngredientTemplateSemanticKeys(in: context)
    populatePlannedMealSemanticKeys(in: context)
    populateRecipeSemanticKeys(in: context)
    
    try? context.save()
    UserDefaults.standard.set(true, forKey: stageAKey)
    
    print("‚úÖ Stage A complete - fields added and populated")
}

private func populateCategorySemanticKeys(in context: NSManagedObjectContext) {
    let request: NSFetchRequest<Category> = Category.fetchRequest()
    guard let categories = try? context.fetch(request) else { return }
    
    for category in categories {
        if let displayName = category.displayName {
            category.normalizedName = Category.normalize(displayName)
            category.updatedAt = Date()
        }
    }
}

// Similar for other entities...
```

**Wait for CloudKit Sync:**
- All devices upgrade to Stage A
- Semantic keys populate on all devices
- CloudKit syncs clean data everywhere
- Monitor: 24-48 hours (or immediate if testing)

---

### **Stage B: Add Constraints (Model Version 3)**

**Goal:** Enforce uniqueness now that all devices have clean data

**Core Data Model Changes:**
```swift
// Make semantic keys REQUIRED (non-optional)
Category {
    displayName: String        // Required
    normalizedName: String     // Required, INDEXED
    updatedAt: Date           // Required
}

IngredientTemplate {
    displayName: String        // Required
    canonicalName: String      // Required, INDEXED
    createdAt: Date           // Required
    updatedAt: Date           // Required
}

PlannedMeal {
    date: Date                // Required
    mealType: String          // Required
    slotKey: String           // Required, INDEXED
    createdAt: Date           // Required
    recipe: Recipe?
    mealPlan: MealPlan?
}

Recipe {
    displayName: String        // Required
    titleKey: String?         // Optional (for detection only)
    createdAt: Date           // Required
}

// Add uniqueness constraints:
// - Category.normalizedName (unique)
// - IngredientTemplate.canonicalName (unique)
// - PlannedMeal.slotKey (unique)
```

**Constraint Configuration in Xcode:**
1. Select entity (e.g., Category)
2. Click "+" under Constraints section
3. Add constraint on `normalizedName`
4. Repeat for IngredientTemplate.canonicalName
5. Repeat for PlannedMeal.slotKey

**Migration Code:**
```swift
private func performStageBMigration(in context: NSManagedObjectContext) {
    let stageBKey = "M7.1.3.StageB.Completed"
    guard !UserDefaults.standard.bool(forKey: stageBKey) else {
        print("‚ÑπÔ∏è Stage B migration already completed")
        return
    }
    
    print("üöÄ Stage B: Adding uniqueness constraints...")
    
    // Constraints are defined in model, just verify
    verifyStageBConstraints(in: context)
    
    UserDefaults.standard.set(true, forKey: stageBKey)
    
    print("‚úÖ Stage B complete - constraints active")
}
```

**Merge Policy:**
```swift
// In Persistence.swift init
container.viewContext.mergePolicy = NSMergeByPropertyObjectTrumpMergePolicy
container.viewContext.automaticallyMergesChangesFromParent = true

// This handles edge-case constraint conflicts:
// - Last-write-wins
// - Logs conflict in debug builds
// - Acceptable for M7.1.3 (eventual consistency)
```

---

### **Timeline for Two-Stage Migration**

**For Development/Testing (M7.1.3):**
- Stage A: Implement ‚Üí Test on simulator ‚Üí Deploy to 2 test devices
- Wait: 1 hour (verify CloudKit sync between devices)
- Stage B: Implement ‚Üí Test on simulator ‚Üí Deploy to 2 test devices
- Total: Can complete in single development session

**For Production (Future):**
- Stage A: Deploy ‚Üí Monitor ‚Üí Wait 7 days
- Stage B: Deploy after all users upgraded
- Ensures zero constraint conflicts

**For M7.1.3:** We can do both stages in sequence during development since no real users.

---

## üìä DETAILED ENTITY SPECIFICATIONS

### **1. Category - System Data (Zero Duplicates)**

#### **Stage A: Core Data Model Changes**
```swift
Category {
    // Renamed field (migration required):
    displayName: String?       // Was: name
    
    // New semantic key:
    normalizedName: String?    // Computed from displayName
    
    // New metadata:
    updatedAt: Date?          // For conflict resolution
    
    // Existing fields:
    id: UUID?
    color: String?
    dateCreated: Date?
    isDefault: Bool
    sortOrder: Int16
    
    // Existing relationship:
    groceryItems: [GroceryItem]
}
```

#### **Stage B: Add Constraints**
```swift
// Make fields required:
displayName: String           // Required
normalizedName: String        // Required, INDEXED

// Add uniqueness constraint on normalizedName
```

#### **Canonical Normalization Helper**
```swift
extension Category {
    /// Canonical normalization used everywhere: repos, queries, UI
    static func normalize(_ name: String) -> String {
        name.lowercased()
            .trimmingCharacters(in: .whitespacesAndNewlines)
            .replacingOccurrences(of: "\\s+", with: " ", options: .regularExpression)
    }
    
    /// Compute normalized name from display name
    func updateNormalizedName() {
        if let display = displayName {
            normalizedName = Category.normalize(display)
        }
    }
}
```

#### **Repository Interface**
```swift
protocol CategoryRepository {
    func getOrCreateCategory(displayName: String, 
                           in context: NSManagedObjectContext) throws -> Category
    func fetchAllCategories(in context: NSManagedObjectContext) throws -> [Category]
    func fetchCategory(normalizedName: String,
                      in context: NSManagedObjectContext) throws -> Category?
}
```

#### **Repository Implementation**
```swift
final class DefaultCategoryRepository: CategoryRepository {
    func getOrCreateCategory(displayName: String, 
                           in context: NSManagedObjectContext) throws -> Category {
        let normalized = Category.normalize(displayName)
        
        // ALWAYS query by semantic key first
        if let existing = try fetchCategory(normalizedName: normalized, in: context) {
            return existing  // ‚úÖ Found existing
        }
        
        // Only create if doesn't exist
        let category = Category(context: context)
        category.id = UUID()
        category.displayName = displayName
        category.normalizedName = normalized
        category.updatedAt = Date()
        category.dateCreated = Date()
        category.sortOrder = 0
        category.isDefault = false
        
        return category
    }
    
    func fetchCategory(normalizedName: String,
                      in context: NSManagedObjectContext) throws -> Category? {
        let request: NSFetchRequest<Category> = Category.fetchRequest()
        request.predicate = NSPredicate(format: "normalizedName == %@", normalizedName)
        request.fetchLimit = 1
        
        return try context.fetch(request).first
    }
    
    func fetchAllCategories(in context: NSManagedObjectContext) throws -> [Category] {
        let request: NSFetchRequest<Category> = Category.fetchRequest()
        request.sortDescriptors = [
            NSSortDescriptor(keyPath: \Category.sortOrder, ascending: true),
            NSSortDescriptor(keyPath: \Category.displayName, ascending: true)
        ]
        return try context.fetch(request)
    }
}
```

#### **Files Requiring Changes**
```
1. forager.xcdatamodeld
   - Rename: name ‚Üí displayName
   - Add: normalizedName (String, optional ‚Üí required)
   - Add: updatedAt (Date, optional ‚Üí required)
   - Add index on normalizedName
   - Add constraint on normalizedName (Stage B)

2. Category+CoreDataClass.swift (if using Manual/None codegen)
   - Add: static func normalize(_:) -> String
   - Add: func updateNormalizedName()

3. /Services/CategoryRepository.swift (NEW FILE)
   - Create repository implementation

4. /forager/Persistence.swift
   - Replace Category.createDefaultCategories() with repository
   - Wire up repository as singleton

5. /forager/AddCategoryView.swift
   - Use repository in saveCategory()

6. /forager/ManageCategoriesView.swift
   - Use repository for Uncategorized category

7. Anywhere using Category(context:)
   - Replace with repository.getOrCreateCategory()
```

---

### **2. IngredientTemplate - Critical Feature Data**

#### **Stage A: Core Data Model Changes**
```swift
IngredientTemplate {
    // Renamed field (migration required):
    displayName: String?       // Was: name
    
    // New semantic key:
    canonicalName: String?     // Computed via normalization pipeline
    
    // New metadata:
    createdAt: Date?          // Creation tracking
    updatedAt: Date?          // Conflict resolution
    
    // Existing fields:
    id: UUID?
    category: String?
    dateCreated: Date?
    isStaple: Bool
    usageCount: Int32
    
    // Existing relationships:
    ingredients: [Ingredient]
    stapleItems: [GroceryItem]
}
```

#### **Stage B: Add Constraints**
```swift
// Make fields required:
displayName: String           // Required
canonicalName: String         // Required, INDEXED

// Add uniqueness constraint on canonicalName
```

#### **Canonical Normalization Helper**
```swift
extension IngredientTemplate {
    /// Uses EXISTING IngredientTemplateService normalization pipeline
    /// Phases 1-4: quantity removal, unit removal, plural normalization, etc.
    static func normalize(_ name: String) -> String {
        // Leverage existing IngredientTemplateService.normalize()
        // Don't duplicate logic - call the existing service method
        let service = IngredientTemplateService.shared
        return service.normalize(name: name)
    }
    
    /// Compute canonical name from display name
    func updateCanonicalName() {
        if let display = displayName {
            canonicalName = IngredientTemplate.normalize(display)
        }
    }
}
```

#### **Service Enhancement**
```swift
// Enhance existing IngredientTemplateService
class IngredientTemplateService {
    /// Enhanced to use semantic keys
    func getOrCreateTemplate(name: String, category: String? = nil) -> IngredientTemplate {
        let canonical = normalize(name: name)
        
        // Query by semantic key
        let request: NSFetchRequest<IngredientTemplate> = IngredientTemplate.fetchRequest()
        request.predicate = NSPredicate(format: "canonicalName == %@", canonical)
        request.fetchLimit = 1
        
        if let existing = try? context.fetch(request).first {
            existing.usageCount += 1
            existing.updatedAt = Date()
            return existing  // ‚úÖ Found via semantic key
        }
        
        // Create new template
        let template = IngredientTemplate(context: context)
        template.id = UUID()
        template.displayName = name
        template.canonicalName = canonical
        template.category = category
        template.createdAt = Date()
        template.updatedAt = Date()
        template.usageCount = 1
        template.isStaple = false
        
        return template
    }
}
```

#### **Files Requiring Changes**
```
1. forager.xcdatamodeld
   - Rename: name ‚Üí displayName
   - Add: canonicalName (String, optional ‚Üí required)
   - Add: createdAt (Date, optional)
   - Add: updatedAt (Date, optional ‚Üí required)
   - Add index on canonicalName
   - Add constraint on canonicalName (Stage B)

2. IngredientTemplate+CoreDataClass.swift
   - Add: static func normalize(_:) -> String (delegates to service)
   - Add: func updateCanonicalName()

3. /Services/IngredientTemplateService.swift
   - Enhance findOrCreateTemplate() ‚Üí getOrCreateTemplate()
   - Add canonicalName field usage
   - Query by canonicalName before creating

4. /forager/CreateRecipeView.swift
   - Already uses service (minor update for displayName)

5. Anywhere using IngredientTemplate(context:)
   - Replace with service.getOrCreateTemplate()
```

---

### **3. PlannedMeal - Strict Slot Uniqueness (NEW)**

#### **Stage A: Core Data Model Changes**
```swift
PlannedMeal {
    // New field for slot protection:
    mealType: String?          // "breakfast", "lunch", "dinner", "snack"
    
    // New semantic key:
    slotKey: String?           // Computed from date + mealType
    
    // New metadata:
    createdAt: Date?          // Creation tracking
    
    // Existing fields:
    id: UUID?
    date: Date?
    notes: String?
    servings: Int16
    scaleFactor: Double
    completedDate: Date?
    createdDate: Date?
    isCompleted: Bool
    
    // Existing relationships:
    recipe: Recipe?
    mealPlan: MealPlan?
}
```

#### **Stage B: Add Constraints**
```swift
// Make fields required:
mealType: String              // Required
slotKey: String               // Required, INDEXED

// Add uniqueness constraint on slotKey
```

#### **Canonical Normalization Helper**
```swift
extension PlannedMeal {
    /// Canonical slot key generation using user's timezone
    static func slotKey(for date: Date, mealType: String) -> String {
        let calendar = Calendar.current  // User's current timezone
        let formatter = DateFormatter()
        formatter.calendar = calendar
        formatter.dateFormat = "yyyy-MM-dd"
        
        let dateString = formatter.string(from: date)
        let normalizedType = mealType.lowercased().trimmingCharacters(in: .whitespaces)
        
        return "\(dateString)-\(normalizedType)"
    }
    
    /// Compute slot key from date and mealType
    func updateSlotKey() {
        if let date = date, let type = mealType {
            slotKey = PlannedMeal.slotKey(for: date, mealType: type)
        }
    }
}
```

#### **Repository Interface**
```swift
protocol PlannedMealRepository {
    func getOrCreatePlannedMeal(date: Date,
                               mealType: String,
                               in context: NSManagedObjectContext) throws -> PlannedMeal
    func fetchPlannedMeal(date: Date,
                         mealType: String,
                         in context: NSManagedObjectContext) throws -> PlannedMeal?
    func fetchPlannedMeals(for mealPlan: MealPlan,
                          in context: NSManagedObjectContext) throws -> [PlannedMeal]
}
```

#### **Repository Implementation**
```swift
final class DefaultPlannedMealRepository: PlannedMealRepository {
    func getOrCreatePlannedMeal(date: Date,
                               mealType: String,
                               in context: NSManagedObjectContext) throws -> PlannedMeal {
        // Check for existing slot
        if let existing = try fetchPlannedMeal(date: date, mealType: mealType, in: context) {
            return existing
        }
        
        // Create new planned meal
        let plannedMeal = PlannedMeal(context: context)
        plannedMeal.id = UUID()
        plannedMeal.date = date
        plannedMeal.mealType = mealType
        plannedMeal.slotKey = PlannedMeal.slotKey(for: date, mealType: mealType)
        plannedMeal.createdAt = Date()
        plannedMeal.createdDate = Date()
        plannedMeal.servings = 4
        plannedMeal.scaleFactor = 1.0
        plannedMeal.isCompleted = false
        
        return plannedMeal
    }
    
    func fetchPlannedMeal(date: Date,
                         mealType: String,
                         in context: NSManagedObjectContext) throws -> PlannedMeal? {
        let slotKey = PlannedMeal.slotKey(for: date, mealType: mealType)
        
        let request: NSFetchRequest<PlannedMeal> = PlannedMeal.fetchRequest()
        request.predicate = NSPredicate(format: "slotKey == %@", slotKey)
        request.fetchLimit = 1
        
        return try context.fetch(request).first
    }
    
    func fetchPlannedMeals(for mealPlan: MealPlan,
                          in context: NSManagedObjectContext) throws -> [PlannedMeal] {
        let request: NSFetchRequest<PlannedMeal> = PlannedMeal.fetchRequest()
        request.predicate = NSPredicate(format: "mealPlan == %@", mealPlan)
        request.sortDescriptors = [
            NSSortDescriptor(keyPath: \PlannedMeal.date, ascending: true),
            NSSortDescriptor(keyPath: \PlannedMeal.mealType, ascending: true)
        ]
        return try context.fetch(request)
    }
}
```

#### **UI Behavior**
```swift
// When user tries to assign recipe to occupied slot
func assignRecipeToSlot(recipe: Recipe, date: Date, mealType: String) {
    let repository = DefaultPlannedMealRepository()
    
    do {
        // Try to get or create
        let plannedMeal = try repository.getOrCreatePlannedMeal(
            date: date,
            mealType: mealType,
            in: viewContext
        )
        
        if plannedMeal.recipe != nil && plannedMeal.recipe != recipe {
            // Slot occupied - show dialog
            showSlotOccupiedDialog(
                existing: plannedMeal.recipe!,
                new: recipe,
                onReplace: {
                    plannedMeal.recipe = recipe
                    try? viewContext.save()
                }
            )
        } else {
            // Slot free or same recipe
            plannedMeal.recipe = recipe
            try? viewContext.save()
        }
    } catch {
        print("Error assigning recipe: \\(error)")
    }
}

func showSlotOccupiedDialog(existing: Recipe, new: Recipe, onReplace: @escaping () -> Void) {
    let alert = UIAlertController(
        title: "Meal Slot Occupied",
        message: "You already have \"\\(existing.displayName ?? "a meal")\" planned. Replace it with \"\\(new.displayName ?? "this meal")\"?",
        preferredStyle: .alert
    )
    
    alert.addAction(UIAlertAction(title: "Replace", style: .destructive) { _ in
        onReplace()
    })
    
    alert.addAction(UIAlertAction(title: "Cancel", style: .cancel))
    
    present(alert, animated: true)
}
```

#### **Files Requiring Changes**
```
1. forager.xcdatamodeld
   - Add: mealType (String, optional ‚Üí required)
   - Add: slotKey (String, optional ‚Üí required)
   - Add: createdAt (Date, optional)
   - Add index on slotKey
   - Add constraint on slotKey (Stage B)

2. PlannedMeal+CoreDataClass.swift (NEW FILE if Manual/None)
   - Add: static func slotKey(for:mealType:) -> String
   - Add: func updateSlotKey()

3. /Services/PlannedMealRepository.swift (NEW FILE)
   - Create repository implementation

4. /Services/MealPlanService.swift
   - Update to use repository for PlannedMeal creation
   - Add slot collision handling

5. UI files that create PlannedMeals
   - Use repository instead of PlannedMeal(context:)
   - Add slot occupied dialog
```

#### **MealType Enumeration (Recommended)**
```swift
enum MealType: String, CaseIterable {
    case breakfast = "breakfast"
    case lunch = "lunch"
    case dinner = "dinner"
    case snack = "snack"
    
    var displayName: String {
        rawValue.capitalized
    }
}

// In PlannedMeal model:
// mealType: String (store rawValue)

// In UI:
// Picker(selection: $selectedMealType) {
//     ForEach(MealType.allCases) { type in
//         Text(type.displayName).tag(type.rawValue)
//     }
// }
```

---

### **4. Recipe - User Content (Detect + Assist)**

#### **Stage A: Core Data Model Changes**
```swift
Recipe {
    // Renamed field (migration required):
    displayName: String?       // Was: title
    
    // New field for duplicate detection:
    titleKey: String?         // Normalized displayName for detection
    
    // Existing fields:
    id: UUID?
    instructions: String?
    cookTime: Int16
    prepTime: Int16
    servings: Int16
    sourceURL: String?
    isFavorite: Bool
    lastUsed: Date?
    usageCount: Int32
    dateCreated: Date?        // Ensure present
    
    // Existing relationships:
    ingredients: [Ingredient]
    groceryListItems: [GroceryListItem]
    plannedMeals: PlannedMeal?
}
```

#### **Stage B: No Constraints**
```swift
// titleKey remains optional
// NO uniqueness constraint (allow intentional duplicates)
```

#### **Canonical Normalization Helper**
```swift
extension Recipe {
    /// Normalize title for duplicate detection
    static func normalize(_ title: String) -> String {
        title.lowercased()
            .trimmingCharacters(in: .whitespacesAndNewlines)
            .replacingOccurrences(of: "\\s+", with: " ", options: .regularExpression)
            .replacingOccurrences(of: "[^a-z0-9\\s]", with: "", options: .regularExpression)
    }
    
    /// Compute title key from display name
    func updateTitleKey() {
        if let display = displayName {
            titleKey = Recipe.normalize(display)
        }
    }
}
```

#### **Duplicate Detection Service**
```swift
final class RecipeDuplicateDetector {
    struct DuplicateMatch {
        let recipe: Recipe
        let similarity: Double  // Could add fuzzy matching later
    }
    
    func findSimilarRecipes(title: String, 
                           excluding: Recipe? = nil,
                           in context: NSManagedObjectContext) -> [DuplicateMatch] {
        let titleKey = Recipe.normalize(title)
        
        let request: NSFetchRequest<Recipe> = Recipe.fetchRequest()
        request.predicate = NSPredicate(format: "titleKey == %@ AND self != %@", 
                                       titleKey, 
                                       excluding ?? NSNull())
        request.sortDescriptors = [
            NSSortDescriptor(keyPath: \Recipe.usageCount, ascending: false),
            NSSortDescriptor(keyPath: \Recipe.dateCreated, ascending: false)
        ]
        
        let matches = (try? context.fetch(request)) ?? []
        return matches.map { DuplicateMatch(recipe: $0, similarity: 1.0) }
    }
}
```

#### **UI Flow**
```swift
func saveRecipe() {
    // Update title key
    recipe.updateTitleKey()
    
    // Check for duplicates
    let detector = RecipeDuplicateDetector()
    let duplicates = detector.findSimilarRecipes(
        title: recipe.displayName ?? "",
        excluding: recipe,
        in: viewContext
    )
    
    if !duplicates.isEmpty {
        showDuplicateDetectionDialog(duplicates: duplicates)
    } else {
        // No duplicates, save immediately
        try? viewContext.save()
        dismiss()
    }
}

func showDuplicateDetectionDialog(duplicates: [RecipeDuplicateDetector.DuplicateMatch]) {
    guard let first = duplicates.first else { return }
    
    let alert = UIAlertController(
        title: "Similar Recipe Found",
        message: """
        You have a recipe called "\\(first.recipe.displayName ?? "")"
        created \\(formatDate(first.recipe.dateCreated)) with \\(first.recipe.usageCount) uses.
        """,
        preferredStyle: .alert
    )
    
    alert.addAction(UIAlertAction(title: "View Existing", style: .default) { _ in
        navigateToRecipe(first.recipe)
    })
    
    alert.addAction(UIAlertAction(title: "Save as New", style: .default) { _ in
        try? viewContext.save()
        dismiss()
    })
    
    alert.addAction(UIAlertAction(title: "Cancel", style: .cancel))
    
    present(alert, animated: true)
}
```

#### **Files Requiring Changes**
```
1. forager.xcdatamodeld
   - Rename: title ‚Üí displayName
   - Add: titleKey (String, optional, indexed)

2. Recipe+CoreDataClass.swift
   - Add: static func normalize(_:) -> String
   - Add: func updateTitleKey()

3. /Services/RecipeDuplicateDetector.swift (NEW FILE)
   - Create detection service

4. /forager/CreateRecipeView.swift
   - Add duplicate detection before save
   - Add detection dialog UI

5. /forager/EditRecipeView.swift
   - Add duplicate detection on title change
   - Add detection dialog UI
```

---

### **5. WeeklyList - Just a List (No Uniqueness)**

#### **Core Data Model Changes**
```swift
WeeklyList {
    // Renamed field (migration required):
    displayName: String?       // Was: name
    
    // Existing fields (no semantic key needed):
    id: UUID?
    notes: String?
    isCompleted: Bool
    dateCreated: Date?
    
    // Existing relationships:
    items: [GroceryListItem]  // CASCADE DELETE
}
```

#### **Rationale**
WeeklyList is just a shopping list container:
- User creates lists whenever they want
- No date range tracking
- No uniqueness constraint
- Multiple lists can exist simultaneously
- It's a simple list, not a calendar-based entity

#### **Files Requiring Changes**
```
1. forager.xcdatamodeld
   - Rename: name ‚Üí displayName
   - NO semantic keys
   - NO constraints

2. /forager/WeeklyListsView.swift
   - Update to use displayName
   - Continue using direct WeeklyList(context:) creation
```

---

### **6. MealPlan - Week Container (No Uniqueness)**

#### **Core Data Model Changes**
```swift
MealPlan {
    // Renamed field (migration required):
    displayName: String?       // Was: name
    
    // Existing fields (no semantic key needed):
    id: UUID?
    startDate: Date?
    duration: Int16
    isActive: Bool
    isCompleted: Bool
    completedDate: Date?
    createdDate: Date?
    
    // Existing relationships:
    plannedMeals: [PlannedMeal]  // CASCADE DELETE
}
```

#### **Rationale**
MealPlan is a container for PlannedMeals:
- User can create multiple meal plans
- PlannedMeal (not MealPlan) enforces slot uniqueness
- MealPlan is like a folder, not a calendar slot
- Multiple plans can exist (e.g., "This Week", "Meal Prep Ideas")

#### **Files Requiring Changes**
```
1. forager.xcdatamodeld
   - Rename: name ‚Üí displayName
   - NO semantic keys
   - NO constraints

2. /Services/MealPlanService.swift
   - Update to use displayName
   - Use PlannedMealRepository for slot protection
```

---

### **7. GroceryListItem - Allow Duplicates (No Changes)**

#### **Rationale (Documented)**
GroceryListItem duplicates are **by design**:
- Same item can appear from multiple recipes
- Same item can appear from multiple sources (recipe + manual + staple)
- Consolidation happens at UI layer only
- No semantic keys, no constraints, no repository pattern

#### **Example Valid Duplicates**
```
WeeklyList "This Week":
  - GroceryListItem: "2 cups flour" (source: "Banana Bread recipe")
  - GroceryListItem: "1 cup flour" (source: "Cookies recipe")
  - GroceryListItem: "1 bag flour" (source: "manual")

UI shows: "Flour (consolidate 3 items)"
Data keeps: 3 separate GroceryListItem records
```

**This is not missing logic - it's the correct architecture.**

#### **Files Requiring Changes**
```
1. forager.xcdatamodeld
   - Rename: name ‚Üí displayName
   - NO semantic keys
   - NO constraints

2. Continue using direct GroceryListItem(context:) creation
```

---

## üîÑ CANONICAL NORMALIZATION HELPERS

### **Standardization Across Entities**

All normalization must use canonical helpers to ensure consistency:

```swift
// Category normalization
Category.normalize("Produce") 
// ‚Üí "produce"

// IngredientTemplate normalization (uses existing service)
IngredientTemplate.normalize("2 cups Fresh Basil")
// ‚Üí "basil" (via existing IngredientTemplateService pipeline)

// PlannedMeal slot key
PlannedMeal.slotKey(for: date, mealType: "Breakfast")
// ‚Üí "2024-12-10-breakfast"

// Recipe title key
Recipe.normalize("Grandma's Banana Bread")
// ‚Üí "grandmas banana bread"
```

### **Usage Locations**

These helpers must be used consistently in:
1. **Repositories** - Query by semantic key
2. **UI Code** - Display and grouping
3. **Migration Code** - Populating semantic keys
4. **Testing** - Verifying normalization

**Anti-Pattern (Don't Do This):**
```swift
// ‚ùå BAD: Inline normalization
let normalized = category.name?.lowercased()

// ‚úÖ GOOD: Use canonical helper
let normalized = Category.normalize(category.displayName ?? "")
```

---

## üóÇÔ∏è COMPLETE RELATIONSHIP MIGRATION TABLE

### **Relationships Affected by Semantic Uniqueness**

| Parent Entity | Child Entity | Relationship Name | Migration Action | Notes |
|---------------|--------------|-------------------|------------------|-------|
| **Category** | GroceryItem | `categoryEntity` | Update code only | Repository prevents new duplicates |
| **IngredientTemplate** | Ingredient | `ingredientTemplate` | Update code only | Service prevents new duplicates |
| **IngredientTemplate** | GroceryItem | `ingredientTemplate` | Update code only | Service prevents new duplicates |
| **WeeklyList** | GroceryListItem | `items` | No changes | CASCADE DELETE preserved |
| **Recipe** | GroceryListItem | `sourceRecipes` | Update displayName | Many-to-many, no constraints |
| **Recipe** | Ingredient | `ingredients` | Update displayName | CASCADE DELETE preserved |
| **Recipe** | PlannedMeal | `plannedMeals` | Update displayName | One-to-one, no constraints |
| **MealPlan** | PlannedMeal | `plannedMeals` | Update displayName | Repository prevents slot conflicts |

### **No Deduplication Needed!**

Since forager has no production data:
- ‚ùå No deduplication service required
- ‚ùå No relationship migration code required
- ‚úÖ Just update code to use repositories going forward
- ‚úÖ Clean slate implementation

---

## üö® CONSTRAINT CONFLICT HANDLING

### **Merge Policy Configuration**

```swift
// In Persistence.swift init
container.viewContext.mergePolicy = NSMergeByPropertyObjectTrumpMergePolicy
container.viewContext.automaticallyMergesChangesFromParent = true
```

### **What Happens on Constraint Conflict**

**Edge Case Scenario:**
1. Both devices offline
2. Both create Category "Produce" with same normalizedName
3. Both sync to CloudKit
4. CloudKit syncs both back to both devices
5. Core Data detects constraint conflict on normalizedName

**Handling:**
- `NSMergeByPropertyObjectTrump` = Last-write-wins
- Conflict logged in debug builds
- App continues without crash
- Repository pattern prevents creating MORE duplicates
- Eventual consistency resolves edge case

### **Acceptable for M7.1.3**

This is acceptable because:
- Repository pattern means it's rare (only offline simultaneous creation)
- Last-write-wins is reasonable for semantic duplicates
- User sees only one Category in UI (queries by normalizedName)
- No data loss
- Future iterations can add CRDTs or OT if needed

### **Debug Logging**

```swift
// In Persistence.swift
NotificationCenter.default.addObserver(
    forName: .NSManagedObjectContextDidSave,
    object: container.viewContext,
    queue: nil
) { notification in
    if let conflicts = notification.userInfo?[NSInsertedObjectsKey] as? Set<NSManagedObject>,
       !conflicts.isEmpty {
        print("‚ö†Ô∏è Merge conflict detected:")
        for object in conflicts {
            if let category = object as? Category {
                print("   Category: \\(category.displayName ?? "unknown") (\\(category.normalizedName ?? ""))")
            }
            // Log other types...
        }
    }
}
```

---

## üìê ARCHITECTURAL DECISIONS RECORD

This section captures all major architectural decisions made during M7.1.3 planning, the rationale behind each decision, and the alternatives considered. These decisions fundamentally shape forager's data architecture and multi-device sync capabilities.

---

### **ADR-1: Two-Stage Migration Strategy**

**Context:**
CloudKit Core Data can inject duplicate entities during migration if constraints are added before all devices have upgraded. A device receiving a duplicate from CloudKit during migration would crash with `NSConstraintConflictError`.

**Decision:**
Implement two-stage migration:
- **Stage A (Model v2):** Add semantic key fields as optional, populate them, allow CloudKit sync
- **Stage B (Model v3):** Make fields required, add uniqueness constraints

**Rationale:**
1. **Safety:** All devices populate semantic keys before constraints enforced
2. **CloudKit Timing:** Allows sync to complete between stages
3. **Zero Crashes:** Prevents constraint conflicts during migration
4. **Proven Pattern:** Industry standard for distributed system migrations

**Consequences:**
- ‚úÖ Safer migration path
- ‚úÖ Zero risk of constraint conflicts
- ‚úÖ All devices converge to clean state
- ‚ö†Ô∏è Requires two model versions instead of one
- ‚ö†Ô∏è Slightly longer implementation time

**Alternatives Considered:**
1. **Single-stage migration** - REJECTED: CloudKit timing makes this dangerous
2. **Deferred constraints** - REJECTED: Core Data doesn't support this pattern
3. **Manual conflict resolution** - REJECTED: Too complex, error-prone

**Status:** ‚úÖ APPROVED  
**ADR Document:** `docs/architecture/ADR-009-two-stage-migration.md` (to be created in Phase 6)

---

### **ADR-2: PlannedMeal SlotKey (Not MealPlan)**

**Context:**
Need to prevent users from assigning two different meals to same date/mealType slot (e.g., two different breakfasts on Tuesday). Initially unclear whether uniqueness belongs on MealPlan (week container) or PlannedMeal (specific meal on specific date).

**Decision:**
Add `slotKey` to **PlannedMeal**, not MealPlan.

**Rationale:**
1. **Semantic Correctness:** PlannedMeal represents "one meal on one date" - this is what needs uniqueness
2. **MealPlan is a Container:** MealPlan is like a folder holding multiple PlannedMeals for a week
3. **User Intent:** Users plan individual meals, not entire weeks as atomic units
4. **Flexibility:** User can have multiple MealPlans (e.g., "This Week", "Meal Prep Ideas") without conflict

**Consequences:**
- ‚úÖ Correct semantic model
- ‚úÖ Prevents double-booking meal slots
- ‚úÖ Allows multiple MealPlan containers
- ‚ö†Ô∏è Requires new mealType field on PlannedMeal
- ‚úÖ Clear user experience (slot occupied dialog)

**Alternatives Considered:**
1. **MealPlan uniqueness** - REJECTED: Wrong level of granularity, too restrictive
2. **No uniqueness enforcement** - REJECTED: UI would be confusing with conflicts
3. **UI-only validation** - REJECTED: Doesn't work across devices

**Status:** ‚úÖ APPROVED  
**ADR Document:** `docs/architecture/ADR-010-plannedmeal-slot-uniqueness.md` (to be created in Phase 6)

---

### **ADR-3: WeeklyList Has No Semantic Uniqueness**

**Context:**
Initial assumption was "one WeeklyList per ISO week" similar to meal planning. Further analysis revealed WeeklyList is fundamentally different - it's just a shopping list container.

**Decision:**
WeeklyList has NO semantic uniqueness constraint. Users create lists whenever they want.

**Rationale:**
1. **User Model:** "Weekly" is a suggestion, not a constraint - users shop when needed
2. **No Date Range:** WeeklyList has no startDate/endDate fields (unlike MealPlan)
3. **Flexibility:** Users might want multiple lists (e.g., "Costco Trip", "Quick Stop", "Weekly Groceries")
4. **Simple Container:** It's just a list of items, not a calendar-based entity

**Consequences:**
- ‚úÖ Maximum flexibility for users
- ‚úÖ No complex date range validation needed
- ‚úÖ Simpler implementation (no repository pattern)
- ‚úÖ Clear separation: MealPlan = calendar, WeeklyList = shopping

**Alternatives Considered:**
1. **One per ISO week** - REJECTED: Model doesn't support date ranges
2. **Add startDate/duration** - REJECTED: Over-engineering for simple lists
3. **Prevent overlapping dates** - REJECTED: No date fields to check

**Status:** ‚úÖ APPROVED  
**ADR Document:** `docs/architecture/ADR-011-weeklylist-no-uniqueness.md` (to be created in Phase 6)

---

### **ADR-4: Standardize on displayName Field**

**Context:**
Core Data model had inconsistent naming: some entities used `name`, Recipe used `title`, no clear standard. This creates confusion and makes code harder to maintain.

**Decision:**
Rename ALL entity name fields to `displayName` for consistency.

**Rationale:**
1. **Consistency:** One field name across entire model
2. **Clarity:** "displayName" is more explicit than generic "name"
3. **Semantic Meaning:** Clear this is the user-facing display value
4. **Maintenance:** Easier code search, fewer special cases
5. **No Production Data:** Safe to rename during migration

**Consequences:**
- ‚úÖ Consistent field naming across all entities
- ‚úÖ Clearer code throughout app
- ‚úÖ Easier for future developers to understand
- ‚ö†Ô∏è Requires field rename in model migration
- ‚ö†Ô∏è Requires code updates throughout app

**Entities Affected:**
- Category: name ‚Üí displayName
- IngredientTemplate: name ‚Üí displayName
- Recipe: title ‚Üí displayName
- WeeklyList: name ‚Üí displayName
- MealPlan: name ‚Üí displayName
- GroceryItem: name ‚Üí displayName
- GroceryListItem: name ‚Üí displayName
- Ingredient: name ‚Üí displayName

**Alternatives Considered:**
1. **Keep name everywhere** - REJECTED: "title" for Recipe already inconsistent
2. **Use title everywhere** - REJECTED: Less semantic for non-Recipe entities
3. **Mix of name/title** - REJECTED: Inconsistency is the problem

**Status:** ‚úÖ APPROVED  
**ADR Document:** `docs/architecture/ADR-012-displayname-standardization.md` (to be created in Phase 6)

---

### **ADR-5: User Timezone for PlannedMeal SlotKey**

**Context:**
When generating slotKey for PlannedMeal ("2024-12-10-breakfast"), must choose between UTC or user's current timezone. Choice affects how meals appear when user travels.

**Decision:**
Use `Calendar.current` (user's current timezone) for slotKey generation.

**Rationale:**
1. **User Mental Model:** "Tuesday breakfast" should stay "Tuesday breakfast" on user's calendar
2. **Travel Scenario:** Most natural behavior when crossing timezones
3. **Consistency:** Matches how calendar apps handle events
4. **iOS Standard:** Calendar.current is iOS standard for user-facing dates

**Consequences:**
- ‚úÖ Meals stay on correct calendar day
- ‚úÖ Natural user experience
- ‚úÖ Consistent with system Calendar app
- ‚ö†Ô∏è SlotKey technically changes if timezone changes (but same semantic slot)

**Edge Cases Handled:**
- User creates "Tuesday breakfast" in EST ‚Üí Stays Tuesday breakfast
- User travels to PST ‚Üí Still Tuesday breakfast (different UTC, same user date)
- CloudKit syncs correctly (stores date, not slotKey)

**Alternatives Considered:**
1. **UTC-based slotKey** - REJECTED: "Tuesday" could become "Monday" when traveling
2. **Store timezone offset** - REJECTED: Over-complex for marginal benefit
3. **Fixed timezone per user** - REJECTED: Doesn't match iOS patterns

**Status:** ‚úÖ APPROVED  
**ADR Document:** `docs/architecture/ADR-013-timezone-handling.md` (to be created in Phase 6)

---

### **ADR-6: Skip Deduplication Service**

**Context:**
Original plan (v3.0) included complex deduplication service to clean up existing duplicate entities. During planning, confirmed forager has no production users or real data.

**Decision:**
Skip deduplication service entirely. Implement clean architecture from scratch.

**Rationale:**
1. **No Production Data:** App has no real users yet
2. **Clean Slate:** Can implement correct architecture immediately
3. **Time Savings:** Eliminates 3-4 hours of complex migration code
4. **Simpler Code:** No relationship migration logic needed
5. **Lower Risk:** Fewer moving parts = fewer bugs

**Consequences:**
- ‚úÖ 4 hours faster implementation
- ‚úÖ Simpler codebase
- ‚úÖ No migration bugs
- ‚úÖ Clean architecture from day 1
- ‚ö†Ô∏è Cannot reuse if app had production data (acceptable tradeoff)

**Alternatives Considered:**
1. **Implement deduplication anyway** - REJECTED: Unnecessary work
2. **Partial deduplication** - REJECTED: All-or-nothing scenario
3. **Future-proof for scale** - REJECTED: YAGNI principle applies

**Status:** ‚úÖ APPROVED  
**Impact:** Reduced estimate from 12-15h to 9-13h  
**ADR Document:** `docs/architecture/ADR-014-skip-deduplication.md` (to be created in Phase 6)

---

### **ADR-7: Repository Pattern for Semantic Uniqueness**

**Context:**
Need mechanism to prevent duplicate entity creation across multiple devices. Core Data + CloudKit provide no built-in semantic uniqueness - only UUID uniqueness.

**Decision:**
Implement Repository Pattern with get-or-create semantics for entities requiring uniqueness.

**Rationale:**
1. **Proven Pattern:** Standard approach in Domain-Driven Design
2. **Query Before Create:** ALWAYS check by semantic key before instantiating
3. **Single Responsibility:** Repositories own entity creation logic
4. **Testable:** Easy to unit test repository logic
5. **CloudKit Safe:** Works with CloudKit's eventual consistency

**Pattern:**
```swift
protocol CategoryRepository {
    func getOrCreateCategory(displayName: String) -> Category
}

// Implementation ALWAYS queries first
let normalized = Category.normalize(displayName)
if let existing = try fetch(normalizedName: normalized) {
    return existing  // ‚úÖ Found
}
// Only create if doesn't exist
let category = Category(context: context)
category.normalizedName = normalized
return category
```

**Consequences:**
- ‚úÖ Guaranteed semantic uniqueness going forward
- ‚úÖ Clean separation of concerns
- ‚úÖ Testable creation logic
- ‚úÖ CloudKit-safe (no race conditions)
- ‚ö†Ô∏è Requires discipline (no direct entity instantiation)

**Entities Using Pattern:**
- Category ‚Üí CategoryRepository
- IngredientTemplate ‚Üí Enhanced IngredientTemplateService
- PlannedMeal ‚Üí PlannedMealRepository

**Alternatives Considered:**
1. **Uniqueness constraints only** - REJECTED: CloudKit can bypass constraints
2. **Custom merge policy** - REJECTED: Doesn't prevent creation, only resolves conflicts
3. **CloudKit unique indexes** - REJECTED: Not supported by Core Data + CloudKit
4. **Manual checks everywhere** - REJECTED: Error-prone, not DRY

**Status:** ‚úÖ APPROVED  
**ADR Document:** `docs/architecture/ADR-015-repository-pattern.md` (to be created in Phase 6)

---

### **ADR-8: Recipe Duplicate Detection (Not Prevention)**

**Context:**
Recipes can have intentionally similar names (e.g., "Banana Bread" vs "Banana Bread (Grandma's)"). Need to help users avoid accidental duplicates without preventing intentional ones.

**Decision:**
Implement **detection with user dialog**, NOT automatic prevention.

**Rationale:**
1. **User Intent Unknown:** System cannot know if duplicate is intentional
2. **User Control:** Let user decide (View Existing | Save as New | Cancel)
3. **Flexibility:** Allows recipe variations with similar names
4. **Better UX:** Dialog is informative, not blocking
5. **Existing Patterns:** Similar to macOS file replacement dialogs

**Pattern:**
```swift
On save:
1. Detect similar recipes via titleKey
2. If found ‚Üí Show dialog with existing recipe details
3. User chooses: View Existing | Save as New | Cancel
```

**Consequences:**
- ‚úÖ Users control duplicate decision
- ‚úÖ Prevents accidental duplicates
- ‚úÖ Allows intentional duplicates
- ‚úÖ Informative (shows existing recipe usage count, date)
- ‚ö†Ô∏è Requires UI implementation

**Alternatives Considered:**
1. **Automatic prevention** - REJECTED: Too restrictive, users want variations
2. **No detection** - REJECTED: Accidental duplicates common
3. **Fuzzy matching** - DEFERRED: Exact match sufficient for M7.1.3

**Status:** ‚úÖ APPROVED  
**ADR Document:** `docs/architecture/ADR-016-recipe-duplicate-detection.md` (to be created in Phase 6)

---

### **ADR-9: GroceryListItem Allows Duplicates By Design**

**Context:**
Same grocery item can appear multiple times from different sources (different recipes, manual entry, staples). Need to decide: prevent duplicates or allow them?

**Decision:**
Allow duplicates. Consolidation happens at UI layer only.

**Rationale:**
1. **Multiple Sources:** Item from Recipe A + Recipe B + Manual = 3 valid records
2. **Source Tracking:** Need to track where each item came from
3. **Separate Quantities:** 2 cups (Recipe A) + 1 cup (Recipe B) = separate records
4. **UI Consolidation:** Smart grouping in UI ("Flour - 3 items, consolidate?")
5. **Data Integrity:** Preserves recipe-to-item relationships

**Pattern:**
```swift
Data Layer:
- GroceryListItem "2 cups flour" (source: Recipe A)
- GroceryListItem "1 cup flour" (source: Recipe B)
- GroceryListItem "1 bag flour" (source: manual)

UI Layer:
- Groups by ingredient template
- Shows: "Flour (3 items - consolidate?)"
- User can merge or keep separate
```

**Consequences:**
- ‚úÖ Preserves source relationships
- ‚úÖ Accurate recipe-to-grocery tracking
- ‚úÖ User controls consolidation
- ‚úÖ No data loss
- ‚úÖ Clear separation: data model vs UI logic

**Alternatives Considered:**
1. **Prevent duplicates** - REJECTED: Loses source tracking
2. **Auto-merge by template** - REJECTED: Loses recipe relationships
3. **Single item with multi-source** - REJECTED: Complex relationship model

**Status:** ‚úÖ APPROVED  
**Note:** This is not missing logic - it's the **correct architecture**  
**ADR Document:** `docs/architecture/ADR-017-grocerylistitem-duplicates.md` (to be created in Phase 6)

---

### **ADR-10: Canonical Normalization Helpers**

**Context:**
Normalization logic appears in multiple places: repositories, UI code, testing, migration. Inconsistent normalization creates bugs (e.g., "Produce" vs "produce " with trailing space).

**Decision:**
Implement canonical normalization helpers as static methods on entities. Use EVERYWHERE.

**Rationale:**
1. **Single Source of Truth:** One implementation = no drift
2. **Consistency:** Same normalization in repos, UI, tests, migration
3. **Testability:** Easy to test normalization logic in isolation
4. **Maintainability:** Change in one place updates everywhere
5. **Clarity:** Clear what normalization rules are

**Pattern:**
```swift
extension Category {
    static func normalize(_ name: String) -> String {
        name.lowercased()
            .trimmingCharacters(in: .whitespacesAndNewlines)
            .replacingOccurrences(of: "\\s+", with: " ", 
                                options: .regularExpression)
    }
}

// Usage everywhere:
let normalized = Category.normalize(userInput)
```

**Consequences:**
- ‚úÖ Zero normalization drift
- ‚úÖ Consistent behavior everywhere
- ‚úÖ Easy to test
- ‚úÖ Clear rules
- ‚ö†Ô∏è Must remember to use helpers (no inline normalization)

**Entities with Canonical Helpers:**
- Category.normalize(_:) - lowercase, trim, normalize whitespace
- IngredientTemplate.normalize(_:) - delegates to existing IngredientTemplateService
- PlannedMeal.slotKey(for:mealType:) - date + mealType formatting
- Recipe.normalize(_:) - lowercase, trim, remove punctuation

**Alternatives Considered:**
1. **Inline normalization** - REJECTED: Drift inevitable
2. **Global utility function** - REJECTED: Less discoverable, not semantic
3. **Computed properties** - REJECTED: Doesn't work for query predicates

**Status:** ‚úÖ APPROVED  
**ADR Document:** `docs/architecture/ADR-018-canonical-normalization.md` (to be created in Phase 6)

---

### **ADR-11: NSMergeByPropertyObjectTrumpMergePolicy**

**Context:**
Edge case: both devices offline, both create same semantic entity, both sync to CloudKit. CloudKit accepts both (different UUIDs), syncs back to both devices. Core Data detects constraint conflict.

**Decision:**
Use `NSMergeByPropertyObjectTrumpMergePolicy` for conflict resolution.

**Rationale:**
1. **Last-Write-Wins:** Reasonable for semantic duplicates
2. **No Crashes:** Handles conflicts gracefully
3. **Eventual Consistency:** Both devices converge
4. **Acceptable for M7.1.3:** Edge case is rare (offline simultaneous creation)
5. **Repository Pattern:** Prevents creating MORE duplicates

**Behavior:**
```swift
1. Device A (offline): Creates Category "Produce" (UUID-A)
2. Device B (offline): Creates Category "Produce" (UUID-B)
3. Both sync to CloudKit ‚Üí 2 records exist
4. CloudKit syncs both back to both devices
5. Merge policy: Last-write-wins keeps one
6. UI queries by normalizedName ‚Üí Shows only one
7. Eventually consistent
```

**Consequences:**
- ‚úÖ No crashes
- ‚úÖ Graceful degradation
- ‚úÖ User sees only one in UI
- ‚úÖ Acceptable data loss (just duplicate metadata)
- ‚ö†Ô∏è Edge case possible (rare)

**Alternatives Considered:**
1. **NSMergeByPropertyStoreTrump** - REJECTED: Favors CloudKit over local
2. **NSOverwriteMergePolicy** - REJECTED: Too aggressive
3. **Custom merge policy** - DEFERRED: YAGNI for M7.1.3
4. **CRDT/OT** - DEFERRED: Over-engineering for current needs

**Status:** ‚úÖ APPROVED  
**Future:** Could implement CRDTs if conflicts become problematic  
**ADR Document:** `docs/architecture/ADR-019-merge-policy.md` (to be created in Phase 6)

---

### **Summary: Architectural Decisions Impact**

**Core Principles Established:**
1. Safety first (two-stage migration)
2. Semantic correctness (PlannedMeal not MealPlan)
3. User flexibility (WeeklyList, Recipe duplicates)
4. Consistency (displayName, canonical helpers)
5. Pragmatism (skip deduplication, simple merge policy)

**Technical Debt Avoided:**
- No backward compatibility cruft (no production data)
- No normalization drift (canonical helpers)
- No duplicate creation paths (repository pattern)
- No inconsistent naming (displayName standard)

**Foundation for Future:**
- Clean architecture for App Store launch
- Patterns established for M8+ features
- ADRs document decision rationale
- Learning notes capture implementation journey

---

## üöÄ IMPLEMENTATION PHASES

### **Phase 1: Core Data Model Updates (2-3 hours)**

**Stage A: Add Semantic Keys**

**1.1 Create Model Version 2** (30 min)
- Editor ‚Üí Add Model Version
- Name: "forager 2"
- Set as current version

**1.2 Add Fields (All Optional)** (1 hour)
```
Category:
- Rename: name ‚Üí displayName (String?)
- Add: normalizedName (String?, indexed)
- Add: updatedAt (Date?)

IngredientTemplate:
- Rename: name ‚Üí displayName (String?)
- Add: canonicalName (String?, indexed)
- Add: createdAt (Date?)
- Add: updatedAt (Date?)

PlannedMeal:
- Add: mealType (String?)
- Add: slotKey (String?, indexed)
- Add: createdAt (Date?)

Recipe:
- Rename: title ‚Üí displayName (String?)
- Add: titleKey (String?, indexed)

WeeklyList:
- Rename: name ‚Üí displayName (String?)

MealPlan:
- Rename: name ‚Üí displayName (String?)

GroceryListItem:
- Rename: name ‚Üí displayName (String?)

Ingredient:
- Rename: name ‚Üí displayName (String?)

GroceryItem:
- Rename: name ‚Üí displayName (String?)
```

**1.3 Add Migration Code** (30 min)
```swift
// In Persistence.swift
private func performStageAMigration() {
    // Populate semantic keys for existing data (if any)
    // For M7.1.3: Likely no data, but code for safety
    populateSemanticKeys()
}
```

**1.4 Test Stage A** (30 min)
- Build and run on simulator
- Verify model migration succeeds
- Create test entities
- Verify semantic keys populate

---

**Stage B: Add Constraints**

**1.5 Create Model Version 3** (30 min)
- Editor ‚Üí Add Model Version
- Name: "forager 3"
- Set as current version

**1.6 Make Fields Required & Add Constraints** (30 min)
```
Category:
- displayName: String (required)
- normalizedName: String (required, indexed)
- updatedAt: Date (required)
- Add constraint on normalizedName

IngredientTemplate:
- displayName: String (required)
- canonicalName: String (required, indexed)
- createdAt: Date (required)
- updatedAt: Date (required)
- Add constraint on canonicalName

PlannedMeal:
- mealType: String (required)
- slotKey: String (required, indexed)
- createdAt: Date (required)
- Add constraint on slotKey

Recipe:
- displayName: String (required)
- titleKey: String? (optional, indexed)
```

**1.7 Test Stage B** (30 min)
- Build and run on simulator
- Verify constraints active
- Try to create duplicate (should fail gracefully)
- Verify merge policy handles conflicts

---

### **Phase 2: Repository Implementation (2-3 hours)**

**2.1 Create CategoryRepository** (45 min)
- Create /Services/CategoryRepository.swift
- Implement protocol and DefaultCategoryRepository
- Add canonical normalize() helper to Category extension
- Unit test repository logic

**2.2 Enhance IngredientTemplateService** (45 min)
- Update existing service to use canonicalName
- Leverage existing normalize() logic
- Update getOrCreateTemplate() to query by canonicalName
- Test with existing recipe creation flow

**2.3 Create PlannedMealRepository** (1 hour)
- Create /Services/PlannedMealRepository.swift
- Implement protocol and DefaultPlannedMealRepository
- Add slotKey() helper to PlannedMeal extension
- Add MealType enumeration
- Unit test slot protection

**2.4 Create RecipeDuplicateDetector** (30 min)
- Create /Services/RecipeDuplicateDetector.swift
- Implement findSimilarRecipes()
- Add titleKey normalization to Recipe extension
- Test detection logic

---

### **Phase 3: Code Integration (2-3 hours)**

**3.1 Wire Up Repositories** (30 min)
- Update Persistence.swift to initialize repositories
- Add singletons for easy access
- Configure merge policy

**3.2 Update Category Creation** (45 min)
- Persistence.swift: Replace createDefaultCategories() with repository
- AddCategoryView: Use repository in saveCategory()
- ManageCategoriesView: Use repository for Uncategorized

**3.3 Update IngredientTemplate Creation** (30 min)
- CreateRecipeView: Already uses service (verify)
- Any other locations creating templates

**3.4 Update PlannedMeal Creation** (1 hour)
- MealPlanService: Use PlannedMealRepository
- Add slot occupied dialog UI
- Test meal planning flow

**3.5 Add Recipe Duplicate Detection** (1 hour)
- CreateRecipeView: Add detection before save
- EditRecipeView: Add detection on title change
- Implement detection dialog UI

---

### **Phase 4: Two-Device Testing (2-3 hours)**

**4.1 Environment Setup** (30 min)
- Install on 2 physical devices
- Verify same iCloud account
- Verify same WiFi network
- Test basic sync

**4.2 Repository Pattern Testing** (1 hour)

**Test 1: Category Uniqueness**
```
Device A: Create "Custom Category"
Device B: Wait for sync (10 sec)
Device B: Try to create "Custom Category"
Expected: Repository returns existing, no duplicate
Result: ‚òê PASS ‚òê FAIL
```

**Test 2: IngredientTemplate Uniqueness**
```
Device A: Add "Cilantro" to recipe
Device B: Wait for sync (10 sec)
Device B: Try to add "cilantro" to recipe
Expected: Service returns existing template
Result: ‚òê PASS ‚òê FAIL
```

**Test 3: PlannedMeal Slot Protection**
```
Device A: Add "Pancakes" to Tuesday breakfast
Device B: Wait for sync (10 sec)
Device B: Try to add "Waffles" to Tuesday breakfast
Expected: Repository finds existing, shows dialog
Result: ‚òê PASS ‚òê FAIL
```

**Test 4: Recipe Duplicate Detection**
```
Device A: Create "Banana Bread"
Device B: Wait for sync (10 sec)
Device B: Try to create "Banana Bread"
Expected: Detector finds existing, shows dialog
Result: ‚òê PASS ‚òê FAIL
```

**4.3 Simultaneous Creation (Critical)** (30 min)

```
Phase 1: Both Offline
- Device A: Airplane mode ‚úàÔ∏è
- Device B: Airplane mode ‚úàÔ∏è

Phase 2: Both Create Same Entity
- Device A (offline): Create Category "Test Category"
- Device B (offline): Create Category "Test Category"

Phase 3: Both Online
- Device A: Disable airplane mode
- Device B: Disable airplane mode
- Wait 60 seconds for sync

Phase 4: Verify
- Device A: Check category list
- Device B: Check category list
- Expected: UI shows only one "Test Category"
- Acceptable: 1-2 records internally, UI shows 1
- CloudKit Dashboard: Check record count

Result: ‚òê PASS ‚òê FAIL
Notes: _________________________________
```

**4.4 CloudKit Dashboard Verification** (30 min)
```
Access: https://icloud.developer.apple.com/dashboard
Container: iCloud.com.richhayn.forager
Environment: Development

CD_Category:
- Total records: _______
- Check normalizedName field present: ‚òê
- Check no duplicate normalizedName: ‚òê
- Sample record ID: _______

CD_IngredientTemplate:
- Total records: _______
- Check canonicalName field present: ‚òê
- Check no duplicate canonicalName: ‚òê
- Sample record ID: _______

CD_PlannedMeal:
- Total records: _______
- Check slotKey field present: ‚òê
- Check mealType field present: ‚òê
- Check no duplicate slotKey: ‚òê
- Sample record ID: _______

CD_Recipe:
- Total records: _______
- Check titleKey field present: ‚òê
- Check displayName present: ‚òê
- Sample record ID: _______

Result: ‚òê PASS ‚òê FAIL
```

---

### **Phase 5: Documentation & Cleanup (1 hour)**

**5.1 Create Learning Notes** (30 min)
- Document: docs/learning-notes/25-m7.1.3-cloudkit-sync-integrity.md
- Include: Two-stage migration approach
- Include: Repository pattern benefits
- Include: Test results summary
- Include: Any surprises or challenges

**5.2 Update Project Documentation** (30 min)
- Update: docs/current-story.md (mark ‚úÖ COMPLETE)
- Update: docs/next-prompt.md (strategic decision)
- Update: docs/project-index.md (recent activity)
- Update: docs/roadmap.md (completion summary)
- Commit all changes with M7.1.3 tag

---

### **Phase 6: Create ADRs and Learning Documents (1.5-2 hours)**

**Goal:** Document all architectural decisions and lessons learned for future reference

**6.1 Create Architecture Decision Records** (1 hour)

Create the following ADR documents in `docs/architecture/`:

**ADR-009: Two-Stage Migration Strategy**
```markdown
# ADR-009: Two-Stage Migration for CloudKit Core Data

## Status
Accepted

## Context
CloudKit Core Data can inject duplicate entities during migration if uniqueness 
constraints are added before all devices have upgraded. This creates 
NSConstraintConflictError crashes.

## Decision
Implement two-stage migration:
- Stage A: Add optional semantic key fields, populate, sync
- Stage B: Make required, add constraints

## Rationale
[Full rationale from Architectural Decisions section]

## Consequences
[Full consequences from Architectural Decisions section]

## Alternatives Considered
[Full alternatives from Architectural Decisions section]

## Related Decisions
- ADR-007: Core Data Change Process
- ADR-015: Repository Pattern

## Implementation
- Model Version 2: forager 2.xcdatamodel (Stage A)
- Model Version 3: forager 3.xcdatamodel (Stage B)
- Migration code: Persistence.swift performStageAMigration()

## Date
December 10, 2024

## Author
Rich Hayn
```

**Create these 11 ADR documents** (use template above):
1. `ADR-009-two-stage-migration.md` - Two-stage migration strategy
2. `ADR-010-plannedmeal-slot-uniqueness.md` - PlannedMeal slotKey (not MealPlan)
3. `ADR-011-weeklylist-no-uniqueness.md` - WeeklyList as simple list container
4. `ADR-012-displayname-standardization.md` - Rename all name fields to displayName
5. `ADR-013-timezone-handling.md` - Calendar.current for PlannedMeal slotKey
6. `ADR-014-skip-deduplication.md` - No deduplication service needed
7. `ADR-015-repository-pattern.md` - Repository pattern for semantic uniqueness
8. `ADR-016-recipe-duplicate-detection.md` - User-assisted detection, not prevention
9. `ADR-017-grocerylistitem-duplicates.md` - Allow duplicates by design
10. `ADR-018-canonical-normalization.md` - Single source of truth helpers
11. `ADR-019-merge-policy.md` - NSMergeByPropertyObjectTrumpMergePolicy choice

**ADR Template Structure:**
```markdown
# ADR-XXX: [Decision Title]

## Status
[Proposed | Accepted | Deprecated | Superseded]

## Context
[What is the issue that we're seeing that is motivating this decision?]

## Decision
[What is the change that we're actually proposing or doing?]

## Rationale
[Why did we choose this option?]

## Consequences
[What becomes easier or more difficult to do because of this change?]
- Positive consequences
- Negative consequences
- Neutral consequences

## Alternatives Considered
[What other options did we consider?]

## Related Decisions
[Links to other ADRs that are related]

## Implementation
[How is this decision implemented? References to code/files]

## Date
[When was this decision made?]

## Author
[Who made this decision?]
```

---

**6.2 Create Comprehensive Learning Notes** (30 min)

**Document:** `docs/learning-notes/25-m7.1.3-cloudkit-sync-integrity.md`

**Sections to include:**

**I. Executive Summary**
- What we built: Semantic uniqueness architecture
- Time invested: [actual hours]
- Planning accuracy: [actual vs estimated]
- Key achievements: Zero duplicates, clean architecture, 11 ADRs

**II. Technical Journey**

**A. Two-Stage Migration**
```markdown
## Two-Stage Migration Implementation

### Stage A: Add Optional Fields
[Experience implementing Stage A]
- What went smoothly
- Unexpected challenges
- Time taken vs estimated

### Stage B: Add Constraints
[Experience implementing Stage B]
- How merge policy performed
- Any constraint conflicts encountered
- Time taken vs estimated

### Lessons Learned
- Why two-stage is essential for CloudKit
- How CloudKit sync timing affects migrations
- Best practices for future migrations
```

**B. Repository Pattern**
```markdown
## Repository Pattern for Core Data

### CategoryRepository
- Implementation approach
- Testing strategy
- Integration with existing code

### PlannedMealRepository
- SlotKey generation challenges
- MealType enumeration benefits
- Slot collision dialog UX

### IngredientTemplateService Enhancement
- Leveraging existing normalization
- CanonicalName field integration
- Performance observations

### Key Insights
- Benefits over direct instantiation
- Testing advantages
- Maintenance benefits
```

**C. Field Standardization**
```markdown
## displayName Standardization

### Migration Process
- Rename strategy across 9 entities
- Code search and replace approach
- Verification testing

### Benefits Realized
- Code consistency improvements
- Maintenance simplification
- Developer experience

### Lessons Learned
- When to standardize early
- Migration strategies for field renames
```

**D. Multi-Device Testing**
```markdown
## Two-Device Sync Testing

### Test Environment
- Device A: [model, iOS version]
- Device B: [model, iOS version]
- iCloud account: [same account verified]

### Test Results
- Category uniqueness: [PASS/FAIL, notes]
- IngredientTemplate uniqueness: [PASS/FAIL, notes]
- PlannedMeal slot protection: [PASS/FAIL, notes]
- Recipe duplicate detection: [PASS/FAIL, notes]
- Simultaneous offline creation: [PASS/FAIL, notes]

### Edge Cases Encountered
[Any unexpected behaviors or edge cases]

### CloudKit Dashboard Observations
[Insights from dashboard inspection]

### Performance Metrics
- Average sync latency: [X seconds]
- Repository operations: [X ms]
- CloudKit operations: [X seconds]
```

**III. Architectural Insights**

**A. Decision-Making Process**
```markdown
## How Architectural Decisions Were Made

### Initial Assumptions vs Reality
- Assumption: WeeklyList needs uniqueness
- Reality: It's just a list container
- Learning: Question calendar-based assumptions

- Assumption: MealPlan needs slot protection
- Reality: PlannedMeal is the correct entity
- Learning: Find the semantic boundary carefully

[More examples...]

### Pattern Recognition
- When to use repository pattern
- When to use detection vs prevention
- When to standardize fields
```

**B. Principal Engineer Review Impact**
```markdown
## Integrating Principal Engineer Feedback

### Critical Corrections
1. Two-stage migration (prevented potential crashes)
2. Canonical normalization helpers (prevented drift)
3. Relationship migration clarity (avoided orphans)
4. Merge policy documentation (clarified edge cases)

### Value of External Review
[What we learned from getting architectural review]
```

**IV. Reusable Patterns**

**A. Two-Stage Migration Pattern**
```markdown
## Pattern: Safe CloudKit Core Data Migration

When to use:
- Adding uniqueness constraints to synced entities
- Distributed systems where devices upgrade asynchronously
- Any breaking schema change with CloudKit

Template:
1. Stage A: Add fields as optional
2. Populate fields for all existing data
3. Allow CloudKit sync (24-48 hours in production)
4. Stage B: Make required, add constraints

Benefits:
- Zero constraint conflict errors
- Safe for distributed deployment
- Users never see migration issues
```

**B. Repository Pattern for Core Data**
```markdown
## Pattern: Semantic Uniqueness with Repositories

When to use:
- Preventing duplicate entities across devices
- Enforcing business logic constraints
- Testable entity creation

Template:
[Code template from ADR-015]

Benefits:
- Single responsibility
- Testable in isolation
- CloudKit-safe
```

**C. Canonical Normalization**
```markdown
## Pattern: Single Source of Truth Normalization

When to use:
- Any string-based semantic matching
- Case-insensitive comparisons
- Whitespace normalization

Template:
[Code template from ADR-018]

Benefits:
- Zero normalization drift
- Consistent behavior everywhere
- Easy to test
```

**V. Code Examples**

**Include working code snippets for:**
- CategoryRepository implementation
- PlannedMeal slotKey generation
- Recipe duplicate detection
- Slot occupied dialog
- Migration code (Stage A & B)

**VI. Performance Analysis**

```markdown
## Performance Metrics

### Repository Operations
- Category.getOrCreate: [X ms]
- IngredientTemplate.getOrCreate: [X ms]
- PlannedMeal.getOrCreate: [X ms]

### CloudKit Sync
- Category sync: [X seconds]
- IngredientTemplate sync: [X seconds]
- Recipe sync: [X seconds]

### Meets Targets?
- All operations < 0.5s: [YES/NO]
- CloudKit sync < 5s: [YES/NO]
```

**VII. Future Considerations**

```markdown
## What's Next

### Potential Enhancements
- Fuzzy matching for Recipe duplicate detection
- CRDTs for better conflict resolution (if edge cases increase)
- Offline queue visualization for users

### Technical Debt
- None introduced (clean slate implementation)

### Monitoring
- Track merge conflict frequency in production
- Monitor CloudKit sync latency
- User feedback on duplicate detection dialogs
```

**VIII. Planning Accuracy**

```markdown
## Time Tracking

### Estimated vs Actual
- Phase 1: Estimated [X]h, Actual [X]h ([X]% accuracy)
- Phase 2: Estimated [X]h, Actual [X]h ([X]% accuracy)
- Phase 3: Estimated [X]h, Actual [X]h ([X]% accuracy)
- Phase 4: Estimated [X]h, Actual [X]h ([X]% accuracy)
- Phase 5: Estimated [X]h, Actual [X]h ([X]% accuracy)
- Phase 6: Estimated [X]h, Actual [X]h ([X]% accuracy)

Total: Estimated [X]h, Actual [X]h ([X]% accuracy)
Target: 85-95% (Historical: 89%)
Result: [WITHIN TARGET / BELOW TARGET / ABOVE TARGET]

### What Took Longer Than Expected
[Specific tasks and why]

### What Was Faster Than Expected
[Specific tasks and why]

### Accuracy Improvements for Next Milestone
[Lessons for better estimation]
```

---

**6.3 Update Architecture Documentation Index** (15 min)

**Update:** `docs/architecture/README.md`

Add new ADRs to index:
```markdown
## Architecture Decision Records

### Data & Persistence (ADRs 1-19)
- [ADR-001](001-selective-technical-improvements.md) - Selective Technical Improvements
- [ADR-006](006-consolidate-staples-and-ingredients.md) - Consolidate Staples and Ingredients
- [ADR-007](007-core-data-change-process.md) - Core Data Change Process
- [ADR-009](009-two-stage-migration.md) - Two-Stage Migration Strategy ‚≠ê NEW
- [ADR-010](010-plannedmeal-slot-uniqueness.md) - PlannedMeal Slot Uniqueness ‚≠ê NEW
- [ADR-011](011-weeklylist-no-uniqueness.md) - WeeklyList No Uniqueness ‚≠ê NEW
- [ADR-012](012-displayname-standardization.md) - DisplayName Standardization ‚≠ê NEW
- [ADR-013](013-timezone-handling.md) - Timezone Handling for Slot Keys ‚≠ê NEW
- [ADR-014](014-skip-deduplication.md) - Skip Deduplication Service ‚≠ê NEW
- [ADR-015](015-repository-pattern.md) - Repository Pattern for Semantic Uniqueness ‚≠ê NEW
- [ADR-016](016-recipe-duplicate-detection.md) - Recipe Duplicate Detection ‚≠ê NEW
- [ADR-017](017-grocerylistitem-duplicates.md) - GroceryListItem Duplicates By Design ‚≠ê NEW
- [ADR-018](018-canonical-normalization.md) - Canonical Normalization Helpers ‚≠ê NEW
- [ADR-019](019-merge-policy.md) - Merge Policy for Conflict Resolution ‚≠ê NEW
```

---

**6.4 Cross-Reference Documentation** (15 min)

**Update these files with ADR references:**

**`docs/current-story.md`:**
```markdown
## M7.1.3: CloudKit Sync Integrity ‚úÖ COMPLETE

### Key Architectural Decisions
See comprehensive ADRs in docs/architecture/:
- ADR-009: Two-Stage Migration Strategy
- ADR-015: Repository Pattern
- [List all 11 ADRs]

### Implementation Summary
[Brief summary with ADR links for context]
```

**`docs/roadmap.md`:**
```markdown
## M7.1 CloudKit Sync Foundation ‚úÖ COMPLETE

### M7.1.3 CloudKit Sync Integrity ‚úÖ COMPLETE
- Semantic uniqueness architecture
- 11 architectural decisions documented
- See: docs/learning-notes/25-m7.1.3-cloudkit-sync-integrity.md
- See: docs/architecture/ADR-009 through ADR-019
```

**`docs/project-index.md`:**
```markdown
## Recent Activity

### M7.1.3 CloudKit Sync Integrity (Dec 10, 2024) ‚úÖ COMPLETE
- **Duration:** [X] hours ([X]% planning accuracy)
- **Outcome:** Clean semantic uniqueness architecture
- **ADRs Created:** 11 new architecture decision records
- **Learning Notes:** docs/learning-notes/25-m7.1.3-cloudkit-sync-integrity.md
- **Key Patterns:** Repository pattern, two-stage migration, canonical normalization
```

---

**Phase 6 Deliverables:**

- [ ] 11 ADR documents created in docs/architecture/
- [ ] Comprehensive learning notes with code examples
- [ ] Architecture README.md updated
- [ ] current-story.md cross-referenced
- [ ] roadmap.md updated
- [ ] project-index.md updated
- [ ] All ADRs follow standard template
- [ ] All learning notes include actual metrics
- [ ] Git commit: "M7.1.3 COMPLETE: Add ADRs and learning documentation"

---

## üìä REVISED TIME ESTIMATE

| Phase | Tasks | Estimated Time |
|-------|-------|----------------|
| **Phase 1** | Core Data model (Stage A + B) | 2-3 hours |
| **Phase 2** | Repository implementation | 2-3 hours |
| **Phase 3** | Code integration | 2-3 hours |
| **Phase 4** | Two-device testing | 2-3 hours |
| **Phase 5** | Documentation | 1 hour |
| **Phase 6** | ADRs & Learning Documents | 1.5-2 hours |
| **TOTAL** | | **11-15 hours** |

**Conservative Estimate:** 12 hours

**Time Breakdown by Activity:**
- Implementation (Phases 1-3): 6-9 hours
- Testing (Phase 4): 2-3 hours
- Documentation (Phases 5-6): 2.5-3 hours

**Value of Phase 6:**
While Phase 6 adds 1.5-2 hours, the value is immense:
- 11 ADRs document "why" not just "what"
- Future developers understand decision rationale
- Reusable patterns for M8+ features
- Comprehensive learning notes prevent knowledge loss
- Cross-referenced documentation improves discoverability

**Historical Context:**
- v3.0 estimate: 12-15 hours (included deduplication)
- v4.0 estimate: 11-15 hours (removed deduplication, added Phase 6)
- Net time: Similar, but Phase 6 documentation creates lasting value

---

## ‚úÖ ACCEPTANCE CRITERIA

### **M7.1.3 Acceptance Criteria - All Must Pass**

**1. Core Data Model Updates**
- [ ] All semantic key fields added (Stage A)
- [ ] All uniqueness constraints added (Stage B)
- [ ] All name ‚Üí displayName migrations complete
- [ ] PlannedMeal.mealType field added
- [ ] Model migrations succeed without errors

**2. Repository Pattern Implementation**
- [ ] CategoryRepository implemented and tested
- [ ] IngredientTemplateService enhanced with canonicalName
- [ ] PlannedMealRepository implemented with slot protection
- [ ] RecipeDuplicateDetector implemented
- [ ] All repositories use canonical normalization helpers

**3. Code Integration**
- [ ] All Category creation uses repository
- [ ] All IngredientTemplate creation uses service
- [ ] All PlannedMeal creation uses repository
- [ ] Recipe duplicate detection active in CreateRecipeView
- [ ] Recipe duplicate detection active in EditRecipeView

**4. Multi-Device Sync**
- [ ] Category uniqueness validated across 2 devices
- [ ] IngredientTemplate uniqueness validated across 2 devices
- [ ] PlannedMeal slot protection validated across 2 devices
- [ ] Recipe duplicate detection validated across 2 devices
- [ ] Simultaneous offline creation handled gracefully
- [ ] No crashes from constraint conflicts

**5. CloudKit Dashboard Verification**
- [ ] All semantic key fields present in CloudKit records
- [ ] No duplicate semantic keys in CloudKit
- [ ] Field data matches app data
- [ ] Relationships intact

**6. Performance**
- [ ] Repository operations < 0.01s
- [ ] CloudKit sync < 5s
- [ ] UI operations < 0.5s
- [ ] No performance regressions

**7. User Experience**
- [ ] Recipe duplicate dialog clear and helpful
- [ ] PlannedMeal slot occupied dialog clear
- [ ] No confusing error messages
- [ ] Smooth multi-device experience

**8. Documentation**
- [ ] Learning notes created (comprehensive with code examples)
- [ ] current-story.md updated
- [ ] next-prompt.md updated
- [ ] project-index.md updated
- [ ] roadmap.md updated

**9. Architectural Decision Records (Phase 6)**
- [ ] All 11 ADRs created in docs/architecture/
- [ ] ADR-009: Two-Stage Migration
- [ ] ADR-010: PlannedMeal Slot Uniqueness
- [ ] ADR-011: WeeklyList No Uniqueness
- [ ] ADR-012: DisplayName Standardization
- [ ] ADR-013: Timezone Handling
- [ ] ADR-014: Skip Deduplication
- [ ] ADR-015: Repository Pattern
- [ ] ADR-016: Recipe Duplicate Detection
- [ ] ADR-017: GroceryListItem Duplicates
- [ ] ADR-018: Canonical Normalization
- [ ] ADR-019: Merge Policy
- [ ] Architecture README.md updated with new ADRs
- [ ] Cross-references added to current-story, roadmap, project-index

**Overall Acceptance:** ‚òê ALL CRITERIA MET ‚òê SOME CRITERIA FAILED

---

## üêõ KNOWN EDGE CASES & MITIGATIONS

### **Edge Case 1: Simultaneous Offline Creation**

**Scenario:** Both devices create same semantic entity while offline

**Behavior:**
1. Both create locally with different UUIDs
2. Both sync to CloudKit ‚Üí Two records exist
3. CloudKit syncs both back to both devices
4. Merge policy resolves: last-write-wins
5. UI shows only one (queries by semantic key)

**Mitigation:**
- Repository pattern prevents creating MORE duplicates
- Merge policy handles gracefully (no crash)
- Eventual consistency resolves
- User sees only one in UI

**Impact:** LOW (invisible to user, self-healing)

**Test Coverage:** Phase 4.3 validates this case

---

### **Edge Case 2: User Travels Across Timezones**

**Scenario:** User creates PlannedMeal in EST, travels to PST

**Behavior with Calendar.current:**
- SlotKey uses user's current timezone
- "Tuesday breakfast" remains "Tuesday breakfast"
- Date stays consistent in user's calendar
- CloudKit syncs correctly

**No issues expected** - Calendar.current is correct choice

**Impact:** NONE (by design)

---

### **Edge Case 3: User Wants Intentional Recipe Duplicate**

**Scenario:** User wants "Banana Bread" AND "Banana Bread (Grandma's Version)"

**Behavior:**
- Duplicate detector triggers
- Dialog shows: [View Existing] [Save as New] [Cancel]
- User selects "Save as New"
- Both recipes coexist (no constraint)

**Impact:** NONE (by design, user has control)

**Test Coverage:** Manual testing during Phase 4.2

---

## üìö CRITICAL IMPLEMENTATION NOTES

### **1. Two-Stage Migration is Non-Negotiable**

Do NOT skip directly to constraints. The sequence MUST be:
1. Add optional fields
2. Populate fields
3. Sync across devices
4. Then add constraints

Skipping Stage A causes `NSConstraintConflictError`.

---

### **2. Use Canonical Helpers Everywhere**

NEVER inline normalization logic. Always use:
- `Category.normalize(_:)`
- `IngredientTemplate.normalize(_:)` (delegates to service)
- `PlannedMeal.slotKey(for:mealType:)`
- `Recipe.normalize(_:)`

This ensures consistency across repos, UI, testing.

---

### **3. Repository Pattern is Mandatory**

After Phase 2 completes, these are FORBIDDEN:
```swift
‚ùå Category(context:)
‚ùå IngredientTemplate(context:)
‚ùå PlannedMeal(context:)
```

ALWAYS use:
```swift
‚úÖ repository.getOrCreateCategory()
‚úÖ service.getOrCreateTemplate()
‚úÖ repository.getOrCreatePlannedMeal()
```

---

### **4. Merge Policy Handles Edge Cases**

`NSMergeByPropertyObjectTrumpMergePolicy` is critical:
- Handles simultaneous offline creation
- Last-write-wins is acceptable for M7.1.3
- Logs conflicts in debug
- No crashes

Do NOT remove or change merge policy.

---

### **5. Testing Must Use 2 Physical Devices**

Simulator cannot test:
- Actual CloudKit sync timing
- Offline scenarios
- Constraint conflict resolution
- Real multi-device edge cases

2 iPhones on same iCloud account required.

---

## üìù FILES REQUIRING CHANGES - COMPLETE LIST

### **Core Data Model:**
```
forager.xcdatamodeld/
‚îú‚îÄ‚îÄ forager.xcdatamodel (Version 1 - current)
‚îú‚îÄ‚îÄ forager 2.xcdatamodel (NEW - Stage A)
‚îî‚îÄ‚îÄ forager 3.xcdatamodel (NEW - Stage B)
```

### **New Repository Files:**
```
/Services/
‚îú‚îÄ‚îÄ CategoryRepository.swift (NEW)
‚îú‚îÄ‚îÄ PlannedMealRepository.swift (NEW)
‚îî‚îÄ‚îÄ RecipeDuplicateDetector.swift (NEW)
```

### **New Extension Files (if using Manual/None codegen):**
```
/CoreData/
‚îú‚îÄ‚îÄ Category+Extensions.swift (NEW)
‚îú‚îÄ‚îÄ IngredientTemplate+Extensions.swift (NEW)
‚îú‚îÄ‚îÄ PlannedMeal+Extensions.swift (NEW)
‚îî‚îÄ‚îÄ Recipe+Extensions.swift (NEW)
```

### **Modified Service Files:**
```
/Services/
‚îú‚îÄ‚îÄ IngredientTemplateService.swift (MODIFY - add canonicalName)
‚îî‚îÄ‚îÄ MealPlanService.swift (MODIFY - use PlannedMealRepository)
```

### **Modified Core Files:**
```
/forager/
‚îî‚îÄ‚îÄ Persistence.swift (MODIFY - migration, repositories, merge policy)
```

### **Modified UI Files:**
```
/forager/
‚îú‚îÄ‚îÄ AddCategoryView.swift (MODIFY - use repository)
‚îú‚îÄ‚îÄ ManageCategoriesView.swift (MODIFY - use repository)
‚îú‚îÄ‚îÄ CreateRecipeView.swift (MODIFY - add duplicate detection)
‚îú‚îÄ‚îÄ EditRecipeView.swift (MODIFY - add duplicate detection)
‚îî‚îÄ‚îÄ [MealPlanning UI files] (MODIFY - use PlannedMealRepository)
```

---

## üéì LEARNING OBJECTIVES

After completing M7.1.3, Rich will have mastered:

1. **Two-Stage Migration Strategy**
   - Why optional fields before constraints
   - How CloudKit sync timing affects migrations
   - Safe rollout strategies

2. **Repository Pattern for Core Data**
   - Get-or-create semantics
   - Preventing duplicate entity creation
   - Clean separation of concerns

3. **Semantic Uniqueness Architecture**
   - Designing semantic keys for entities
   - When to use constraints vs detection
   - Balancing strictness with user control

4. **Canonical Normalization**
   - Single source of truth for normalization
   - Consistency across repos, UI, testing
   - Avoiding normalization drift

5. **CloudKit Core Data Multi-Device Patterns**
   - How CloudKit syncs Core Data entities
   - Merge policies for conflict resolution
   - Eventual consistency strategies

6. **Field Naming Standardization**
   - Benefits of consistent naming (displayName)
   - Migration strategies for field renames
   - Code search and replace techniques

7. **Architectural Decision Documentation (NEW)**
   - How to write effective ADRs
   - Capturing decision rationale, not just outcomes
   - Documenting alternatives considered
   - Creating reusable patterns for future work
   - Cross-referencing decisions across documentation

8. **Comprehensive Learning Notes**
   - Documenting implementation journey with code examples
   - Tracking planning accuracy for better estimation
   - Identifying reusable patterns
   - Creating knowledge artifacts for future reference

**Meta-Learning:**
- How architectural decisions compound over time
- Why documenting "why" is as important as "what"
- How to create decision artifacts that help future development
- The value of systematic documentation discipline

---

## ‚úÖ DEFINITION OF DONE

**M7.1.3 is complete when:**

- ‚úÖ Stage A migration implemented and tested
- ‚úÖ Stage B migration implemented and tested
- ‚úÖ All repositories implemented and tested
- ‚úÖ All existing code updated to use repositories
- ‚úÖ Recipe duplicate detection implemented with UI
- ‚úÖ PlannedMeal slot protection implemented
- ‚úÖ All Phase 1-4 test cases pass
- ‚úÖ Two-device sync validated (no crashes, no duplicates)
- ‚úÖ CloudKit Dashboard verification complete
- ‚úÖ Performance targets met (< 0.5s operations, < 5s sync)
- ‚úÖ Documentation updated (learning notes, current-story, next-prompt)
- ‚úÖ **11 ADRs created documenting all architectural decisions**
- ‚úÖ **Architecture documentation cross-referenced**
- ‚úÖ **Comprehensive learning notes with code examples**
- ‚úÖ Git workflow followed (feature branch, PR, squash merge)
- ‚úÖ Zero regressions to M1-M7.1.2 features
- ‚úÖ All name ‚Üí displayName migrations complete

**Phase 6 is critical because:**
- Documents WHY decisions were made, not just WHAT
- Creates reusable patterns for future milestones
- Prevents knowledge loss
- Helps future developers (including future Rich!)
- Establishes architectural principles for forager

---

## üéØ SUCCESS METRICS

### **Planning Accuracy**
- Estimated: 10 hours
- Actual: _______ hours
- Accuracy: _______ % (Actual / Estimated √ó 100)
- Target: 85-95% (Rich's historical: 89%)

### **Quality Metrics**
- Build success: 100% ‚úÖ
- Performance: < 0.5s operations ‚úÖ
- CloudKit sync: < 5s ‚úÖ
- Zero crashes: ‚úÖ
- Zero data loss: ‚úÖ

### **Test Coverage**
- Repository pattern: 100% ‚úÖ
- Multi-device sync: 100% ‚úÖ
- Edge cases: 100% ‚úÖ
- Performance: 100% ‚úÖ

---

**Version History:**
- v1.0 (Dec 5) - Original M7.1.3 PRD (3-4h, basic sync testing)
- v2.0 (Dec 10) - Expanded to comprehensive semantic uniqueness (12-15h)
- v3.0 (Dec 10) - Added detailed test execution template and tracking
- v4.0 (Dec 10) - Simplified scope (no deduplication), two-stage migration, PlannedMeal slotKey, displayName standardization, principal engineer fixes integrated
- v4.1 (Dec 10) - **CURRENT** - Added comprehensive Architectural Decisions section (11 ADRs documented) and Phase 6 for creating ADR documents and learning notes

**Status:** üöÄ READY TO START  
**Next Step:** Phase 1 - Stage A Migration (Core Data model updates)

---

**Document maintained by:** Rich Hayn  
**Last reviewed:** December 10, 2024  
**Review frequency:** After each phase completion

**Principal Engineer Review:** ‚úÖ APPROVED (All architectural concerns addressed)  
**Architectural Decisions:** ‚úÖ DOCUMENTED (11 ADRs captured in detail)