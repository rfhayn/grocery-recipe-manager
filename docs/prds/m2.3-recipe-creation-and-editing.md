# Product Requirements Document
## M2.3: Recipe Creation & Editing

**Version**: 3.1 Final  
**Date**: October 3, 2025  
**Status**: Ready for Implementation  
**Estimated Effort**: 5-6 hours  
**Priority**: HIGH

---

## Executive Summary

Complete the Recipe Management system by implementing professional creation and editing workflows with parse-then-autocomplete, seamless template integration, and batch category assignment.

**Strategic Value**: Complete recipe lifecycle management  
**Dependencies**: M2.2.7 Complete ✅

---

## Problem Statement

### Current State
- Recipe Display: Comprehensive catalog ✅
- Recipe Infrastructure: Full data architecture ✅
- Ingredient System: Unified IngredientTemplate system ✅
- **Missing**: No way to create or edit recipes ❌

### Lessons from Previous Attempt
**Why it failed:**
- Overly complex ingredient alignment
- No autocomplete = tedious entry
- Disconnected category flow
- Rigid template matching

**Critical Requirements:**
1. Parse-Then-Autocomplete: "2 cups flour" → parse → autocomplete on "flour"
2. Fuzzy Matching: "chkn" finds "chicken"
3. Batch Category Assignment: Modal at end, like "Add to List"
4. Automatic Template Alignment: Every ingredient links to IngredientTemplate

---

## Goals & Success Criteria

### Primary Goals
1. Enable Recipe Creation: Professional form
2. Enable Recipe Editing: Maintain data integrity
3. **Parse-Then-Autocomplete**: Extract name for smart matching ⭐
4. **Seamless Template Alignment**: Automatic linking ⭐
5. **Proven Category Flow**: Reuse CategoryAssignmentModal ⭐
6. Performance: All operations < 0.5s

### Success Metrics
- Creation Success Rate: 95%+
- Autocomplete Usage: 70%+
- Template Match Rate: 90%+
- Autocomplete Performance: < 0.1s
- Parsing Performance: < 0.05s
- Category Coverage: 60%+

---

## User Stories

### US-1: Create New Recipe
**As a** home cook  
**I want to** add recipes to the app  
**So that** I can use them for meal planning

**Flow:**
1. Tap "+" in RecipeListView
2. Enter recipe name, times, servings
3. Type ingredient: "2 cups flour"
4. System parses: name="flour"
5. Autocomplete shows: flour, all-purpose flour, whole wheat flour
6. Tap "all-purpose flour"
7. Text becomes "2 cups all-purpose flour" ✓ Baking
8. Add more ingredients
9. Enter instructions, tags
10. Tap "Save Recipe"
11. CategoryAssignmentModal for uncategorized
12. Recipe saves successfully

### US-2: Smart Ingredient Autocomplete ⭐
**As a** recipe creator  
**I want** intelligent autocomplete  
**So that** I can quickly select ingredients

**Critical Detail:**
System parses to extract ingredient name:
- "2 cups flour" → autocomplete on "flour"
- "1 lb ground beef" → autocomplete on "ground beef"
- "1/2 tsp vanilla" → autocomplete on "vanilla"

### US-3: Category Assignment
**As a** recipe creator  
**I want** to assign categories to new ingredients  
**So that** recipes integrate with my ingredient list

**Flow:**
1. Add ingredients: "2 cups flour" ✓, "1 lb ground turkey" ?, "1 tsp paprika" ?
2. Tap "Save Recipe"
3. System creates IngredientTemplate for new ingredients
4. CategoryAssignmentModal appears (reuse M2.2.4)
5. Assign: ground turkey → Meat, paprika → Seasonings
6. Recipe saves with proper transaction order
7. Next time "ground turkey" shows in autocomplete with Meat

---

## Technical Architecture

### Data Models

```swift
// IngredientInput (New)
struct IngredientInput: Identifiable {
    let id = UUID()
    var fullText: String = ""  // "2 cups flour"
    var template: IngredientTemplate?  // READ-ONLY reference
    var matchedViaAutocomplete: Bool = false
    
    var statusIndicator: IngredientStatus {
        if template == nil { return .needsTemplate }
        else if !hasCategory { return .needsCategory }
        else { return .ready }
    }
}

// RecipeFormData (New)
struct RecipeFormData {
    var name: String = ""
    var prepTime: Int = 0
    var cookTime: Int = 0
    var servings: Int = 4
    var instructions: String = ""
    var tags: String = ""
    var isFavorite: Bool = false
    var ingredients: [IngredientInput] = []
    
    func validate() -> [ValidationError]
}
```

---

## Core Data Transaction Management ⭐

### Save Order (CRITICAL)

**Must follow this exact order:**

**Step 1: Create/Update IngredientTemplates First**
```swift
for ingredient in formData.ingredients where ingredient.template == nil {
    let parsed = parsingService.parseIngredient(text: ingredient.fullText)
    
    let template = IngredientTemplate(context: viewContext)
    template.id = UUID()
    template.name = parsed.name  // Clean name: "flour"
    template.category = nil  // Assigned in modal
    template.usageCount = 0
    
    ingredient.template = template
}
```

**Step 2: Create Ingredients with Template Links**
```swift
for (index, ingredientInput) in formData.ingredients.enumerated() {
    let ingredient = Ingredient(context: viewContext)
    ingredient.id = UUID()
    ingredient.name = ingredientInput.fullText  // "2 cups flour"
    ingredient.sortOrder = Int16(index)
    ingredient.recipe = recipe
    ingredient.ingredientTemplate = ingredientInput.template  // READ-ONLY
    
    if let template = ingredientInput.template {
        template.usageCount += 1
    }
}
```

**Step 3: Create Recipe Last**
```swift
let recipe = Recipe(context: viewContext)
recipe.id = UUID()
recipe.title = formData.name
// ... set other fields

try viewContext.save()  // Single save for entire graph
```

### Template Immutability ⚠️ CRITICAL

**Templates are READ-ONLY during recipe creation.**

**What Templates Provide:**
- Clean ingredient name: "flour", "chicken"
- Category: "Baking", "Meat"
- Usage tracking
- Autocomplete

**What Templates DON'T Store:**
- Quantities: "2 cups" NOT in template
- Units: "cups" NOT in template
- Recipe-specific details

**Example:**
```
User types: "2 cups all-purpose flour"

Ingredient:
  name: "2 cups all-purpose flour"  ← Full text
  ingredientTemplate: → points to template

IngredientTemplate (READ-ONLY):
  name: "all-purpose flour"  ← Clean name
  category: "Baking"
```

**Where Templates Change:**
- ✅ IngredientsView: Edit name/category
- ❌ Recipe Creation: NEVER modified
- ❌ Recipe Editing: NEVER modified

**Preventing Contamination:**
```swift
// ✅ CORRECT: Link to existing (read-only)
ingredient.ingredientTemplate = existingTemplate

// ✅ CORRECT: Create new for new ingredient
let newTemplate = IngredientTemplate(context: viewContext)
ingredient.ingredientTemplate = newTemplate

// ❌ WRONG: Never modify existing
existingTemplate.name = "new name"  // DON'T
```

---

## Unsaved Changes Handling ⭐

### Detection
```swift
@State private var hasUnsavedChanges = false
@State private var showingDiscardAlert = false

TextField("Recipe Name", text: $formData.name)
    .onChange(of: formData.name) { _ in
        hasUnsavedChanges = true
    }
```

### Confirmation Dialog
```
┌─────────────────────────────────────┐
│        Discard Changes?             │
├─────────────────────────────────────┤
│ You have unsaved changes.           │
│ Are you sure you want to discard    │
│ them?                               │
│                                     │
│ [Cancel]              [Discard]     │
└─────────────────────────────────────┘
```

### Implementation
```swift
private func handleCancel() {
    if hasUnsavedChanges {
        showingDiscardAlert = true
    } else {
        dismiss()
    }
}

.alert("Discard Changes?", isPresented: $showingDiscardAlert) {
    Button("Cancel", role: .cancel) { }
    Button("Discard", role: .destructive) {
        hasUnsavedChanges = false
        dismiss()
    }
}
```

---

## Out of Scope for M2.3 ⭐

### CloudKit Sync (M5)
- Recipe syncing across devices
- Conflict resolution
- Sync flags

**Rationale**: M2.3 is local-first. Sync is M5.

### Draft Auto-Save (Future)
- Persistent draft storage
- Resume from draft

**Rationale**: In-memory + unsaved warning sufficient.

### Step-by-Step Instructions (M6+)
- Ordered instruction steps
- Drag-to-reorder steps

**Rationale**: Single TextEditor adequate now.

---

## IngredientAutocompleteService ⭐

```swift
class IngredientAutocompleteService: ObservableObject {
    private let parsingService: IngredientParsingService
    @Published var suggestions: [IngredientTemplate] = []
    
    func searchIngredients(fullText: String) {
        guard fullText.count >= 2 else { return }
        
        // Step 1: Parse to extract name
        let parsed = parsingService.parseIngredient(text: fullText)
        let ingredientName = parsed.name
        
        guard ingredientName.count >= 2 else { return }
        
        // Step 2: Autocomplete on name only
        let query = ingredientName.lowercased()
        var results: [IngredientTemplate] = []
        
        // Multi-pass search
        results.append(contentsOf: exactPrefixMatch(query))
        results.append(contentsOf: wordBoundaryMatch(query))
        results.append(contentsOf: containsMatch(query))
        results.append(contentsOf: fuzzyMatch(query))
        
        suggestions = Array(unique(results).prefix(10))
    }
    
    func debouncedSearch(fullText: String) {
        // 0.3s delay
    }
    
    private func fuzzyMatch(_ query: String) -> [IngredientTemplate] {
        // Levenshtein distance <= 2
    }
}
```

---

## Implementation Phases

### Phase 1: Autocomplete (2-2.5 hours) ⭐

**1.1: Service (75-90 min)**
- Create IngredientAutocompleteService
- Parse-then-search pattern
- Multi-pass search
- Debouncing
- Fuzzy matching

**1.2: UI (45-60 min)**
- Autocomplete dropdown
- TextField with onChange
- Template name + category badge
- Text rebuilding on selection
- Manual add fallback

### Phase 2: Templates & Categories (1.5-2 hours)

**2.1: Linking & Transactions (45-60 min)**
- Status indicators (✓ vs ?)
- Exact match fallback
- **Core Data save order**
- **Transaction rollback**

**2.2: Category Assignment (45-60 min)**
- Detect uncategorized
- Create templates
- Integrate CategoryAssignmentModal
- Handle completion

### Phase 3: Editing & Polish (1-1.5 hours)

**3.1: Edit View (45-60 min)**
- Create EditRecipeView
- Pre-populate form
- Load ingredients
- **Unsaved changes detection**

**3.2: Validation & Polish (30-45 min)**
- Form validation
- **Discard confirmation**
- Save indicator
- Success confirmation

---

## UI Design

### Parse-Then-Autocomplete
```
"2 cups flo"
    ↓
Parse: name="flo"
    ↓
Autocomplete: flour, all-purpose flour
    ↓
Select: "all-purpose flour"
    ↓
Rebuild: "2 cups all-purpose flour"
```

### Autocomplete Dropdown
```
┌────────────────────────────────────┐
│ Add: [2 cups flo            ] [+] │
│ ┌── Autocomplete ────────────────┐│
│ │ 🥖 flour            Baking     ││
│ │ 🥖 all-purpose flour  Baking   ││
│ │ 🥖 whole wheat flour  Baking   ││
│ └────────────────────────────────┘│
└────────────────────────────────────┘
```

### Status Indicators
```
✓ Ready:
┌────────────────────────────────────┐
│ ✓ 2 cups all-purpose flour        │
│   Category: Baking                 │
└────────────────────────────────────┘

? Needs Category:
┌────────────────────────────────────┐
│ ? 1 lb ground turkey               │
│   New ingredient - needs category  │
└────────────────────────────────────┘
```

---

## Testing Checklist

### Autocomplete ⭐
- [ ] Appears after 2+ chars in name
- [ ] "2 cups flo" → searches "flo"
- [ ] Fuzzy: "chkn" finds "chicken"
- [ ] Category badges display
- [ ] Rebuilds text correctly
- [ ] Template link created (READ-ONLY)
- [ ] Manual add works
- [ ] Performance < 0.1s

### Core Data Transactions ⭐
- [ ] Templates created first
- [ ] Ingredients with links
- [ ] Recipe created last
- [ ] Single save operation
- [ ] Rollback on error
- [ ] No orphaned relationships
- [ ] Templates immutable

### Unsaved Changes ⭐
- [ ] Flag set on modify
- [ ] Dialog on Cancel
- [ ] Discard dismisses
- [ ] Continue keeps open
- [ ] Flag resets after save

### Template Alignment ⭐
- [ ] All ingredients link to templates
- [ ] Status indicators accurate
- [ ] Ingredient.name = full text
- [ ] Template.name = clean name
- [ ] Templates unchanged

### Category Assignment
- [ ] Modal appears for uncategorized
- [ ] Batch assignment
- [ ] Can skip
- [ ] Persists to templates
- [ ] Next usage shows category

---

## Risk Assessment

### High Risk: Parse Performance
**Risk**: Lag on every keystroke  
**Mitigation**: Debouncing, optimize parsing  
**Contingency**: Simpler regex extraction

### High Risk: Transaction Integrity
**Risk**: Orphaned relationships  
**Mitigation**: Enforce save order, rollback  
**Contingency**: Validation before save

### Medium Risk: Autocomplete Accuracy
**Risk**: Wrong name extraction  
**Mitigation**: Multiple patterns, fuzzy fallback  
**Contingency**: Manual add always available

---

## Success Validation

### Pre-Launch
- [ ] All tests passing
- [ ] Transaction ordering verified
- [ ] Performance < 0.5s saves
- [ ] Unsaved changes tested
- [ ] Template immutability verified

### Post-Launch (Week 1)
- Creation success: 95%+
- Autocomplete usage: 70%+
- Template match: 90%+
- Search time: < 0.1s
- Zero orphaned relationships
- Zero critical bugs

---

## Acceptance Criteria

### Must Have
- [ ] Create recipes with all fields
- [ ] **Parse-then-autocomplete** ⭐
- [ ] **Every ingredient links to template (READ-ONLY)** ⭐
- [ ] **CategoryAssignmentModal** ⭐
- [ ] **Save order: Templates → Ingredients → Recipe** ⭐
- [ ] **Unsaved changes warning** ⭐
- [ ] Edit existing recipes
- [ ] Form validation
- [ ] Transaction rollback on error
- [ ] Performance < 0.5s

### Should Have
- [ ] Fuzzy matching
- [ ] Debounced autocomplete
- [ ] Multi-pass search
- [ ] Ingredient reordering
- [ ] Tags input
- [ ] Clear error messages

### Out of Scope
- CloudKit sync (M5)
- Draft auto-save (future)
- Step-by-step instructions (M6+)
- Nutritional calculations (future)

---

## Dependencies

### Required
- ✅ M2.2.1-M2.2.7 Complete
- ✅ IngredientParsingService
- ✅ IngredientTemplateService
- ✅ CategoryAssignmentModal
- ✅ Performance architecture

---

## Rollout Plan

**Day 1**: Internal testing  
**Days 2-3**: Beta testing  
**Day 4**: Production release  
**Week 1**: Monitoring & iteration

---

## Conclusion

M2.3 completes Recipe Management with:
- **Parse-then-autocomplete** ⭐
- **100% template alignment** ⭐
- **Proven category flow** ⭐
- **Transaction management** ⭐
- **Unsaved changes protection** ⭐

### Critical Success Factors
1. Parse-then-autocomplete smooth
2. Templates automatic & READ-ONLY
3. Save order enforced
4. Performance < 0.1s

### How It Solves The Problem
```
"2 cups flour" → Parse: "flour" → Autocomplete
    ↓
Select: "all-purpose flour"
    ↓
Create: name="2 cups all-purpose flour"
Link: template "all-purpose flour" (READ-ONLY)
    ↓
Result: Perfect alignment + natural UX + integrity
```

---

## Appendix A: Parse-Then-Autocomplete

**Traditional Problem:**
- Types: "2 cups flour"
- Searches: "2 cups flour"
- Database: "flour"
- Result: NO MATCH ❌

**Solution:**
- Types: "2 cups flour"
- Parses: name="flour"
- Searches: "flour"
- Database: "flour"
- Result: MATCH ✓

**Why It Works:**
1. Natural entry
2. Clean matching
3. Automatic alignment
4. Category integration
5. Data integrity

---

## Appendix B: Core Data Transactions

**Wrong Order:**
```swift
// ❌ Recipe first
let recipe = Recipe(...)
let ingredient = Ingredient(...)
ingredient.recipe = recipe
ingredient.ingredientTemplate = nil  // Broken!
```

**Correct Order:**
```swift
// ✅ Templates first
let template = IngredientTemplate(...)

// ✅ Ingredients with links
let ingredient = Ingredient(...)
ingredient.ingredientTemplate = template

// ✅ Recipe last
let recipe = Recipe(...)
ingredient.recipe = recipe

// ✅ Single save
try viewContext.save()
```

**Template Immutability:**
```swift
// ❌ WRONG
let template = findTemplate("flour")
template.name = "3 cups flour"  // Contamination!

// ✅ RIGHT
let template = findTemplate("flour")
let ingredient = Ingredient(...)
ingredient.name = "3 cups flour"  // Full text
ingredient.ingredientTemplate = template  // READ-ONLY
```

---

## Appendix C: Quick Reference

### For Developers
**Key Files:**
- IngredientAutocompleteService.swift (new)
- CreateRecipeView.swift (new)
- EditRecipeView.swift (new)
- RecipeFormData.swift (new)

**Modified:**
- RecipeListView.swift (+ button)
- RecipeDetailView.swift (edit button)

### For Testers
**Test:**
- Autocomplete: "2 cups flo" → flour options
- Fuzzy: "chkn" → chicken
- Transactions: Order correct
- Unsaved: Dialog appears
- Performance: < 0.1s

### For PMs
**Track:**
- Autocomplete usage: 70%+
- Template match: 90%+
- Creation success: 95%+
- Transaction success: 100%

---

## Appendix D: Implementation Checklist

### Phase 1
- [ ] Create IngredientAutocompleteService
- [ ] Parse-then-search
- [ ] Multi-pass search
- [ ] Fuzzy matching
- [ ] Autocomplete UI
- [ ] Text rebuilding

### Phase 2
- [ ] Status indicators
- [ ] **Save order enforcement**
- [ ] **Transaction rollback**
- [ ] Template creation
- [ ] CategoryAssignmentModal integration

### Phase 3
- [ ] EditRecipeView
- [ ] **Unsaved changes detection**
- [ ] **Discard confirmation**
- [ ] Form validation
- [ ] Success feedback

---

**END OF PRD v3.1 FINAL**

**Status**: Production Ready  
**Total Pages**: Complete with all sections  
**Ready**: For implementation