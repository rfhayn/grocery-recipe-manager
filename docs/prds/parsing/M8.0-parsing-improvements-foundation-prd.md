# M8.0: Parsing Improvements Foundation - PRD

**Project**: Forager - Smart Meal Planner  
**Milestone**: M8.0 (Part of M8 Analytics & Insights)  
**Status**: ⏳ PLANNED  
**Version**: 1.0  
**Created**: December 19, 2025  
**Dependencies**: M7 complete (telemetry data from external beta)

---

## Executive Summary

### What is M8.0?

M8.0 implements a **data-driven hybrid NLP system** for ingredient parsing that uses real telemetry from M7 external beta to prioritize improvements where they matter most.

**Hybrid Approach:**
- **Fast Path** (80% of inputs): Existing regex parser (< 0.03s)
- **Smart Path** (15% of inputs): Apple Natural Language framework
- **User Path** (5% of inputs): Manual edit with telemetry

### Why Now?

**Timing**: After M7.6 external beta, before M8.1 analytics dashboard

**Data Available**:
- 10+ external beta testers (M7.6)
- 2-4 weeks of real usage data
- Telemetry showing actual failure patterns
- User corrections showing what matters

**Problem**: Can now justify 8-12h investment with real data instead of speculation

**Solution**: Build NLP enhancement targeting the top 10 actual failure patterns

### Key Outcomes

By the end of M8.0:
- ✅ Parsing accuracy improves from 95% → 98%+ on real-world inputs
- ✅ Low-confidence rate drops from 5% → 2%
- ✅ Complex patterns handled gracefully ("2-3 cloves garlic, minced")
- ✅ Performance maintained (< 0.1s for 98% of inputs)
- ✅ Foundation for future ML evolution (M9.5)

---

## Strategic Context

### The Data-Driven Approach

**M7.5 Telemetry** provides:
```json
{
  "id": "uuid",
  "timestamp": "2025-12-15T10:30:00Z",
  "originalText": "2-3 cloves garlic, minced",
  "parseConfidence": 0.3,
  "wasManuallyEdited": true,
  "correctedText": "2.5 cloves garlic"
}
```

**M8.0 Analysis** reveals:
1. Which patterns fail most often
2. Which patterns users actually correct
3. Which edge cases don't matter (users leave as-is)
4. Performance characteristics of real inputs

**Key Insight**: Don't guess at improvements—let data decide priorities

### Evolution from M7.5

**M7.5 Accomplished:**
- Graceful degradation with edit UI
- Telemetry foundation
- User correction flow

**M8.0 Builds On:**
- Analyze telemetry to find top patterns
- Implement targeted improvements
- Reduce edit flow usage (better first-pass accuracy)

**M9.5 Will Add:**
- Custom ML model
- On-device training
- Self-improving system

---

## User Personas

### Primary: Sarah (External Beta Tester, Power User)

**M7 Experience:**
- Encountered ~20 low-confidence ingredients
- Manually edited 12 of them
- Left 8 as "close enough"

**M7.5 Feedback:**
- "Love the edit feature, but wish it was smarter"
- "Some patterns are obviously wrong"
- "Would be nice if it learned from my edits"

**M8.0 Improvement:**
- Patterns she edited (ranges, parentheticals) now parse correctly
- Edit feature still available for truly weird inputs
- Notices app "getting smarter"

### Secondary: Rich (Developer)

**M7 Experience:**
- 45 logged failures in first 2 weeks
- Top 3 patterns account for 60% of failures
- Some patterns too complex for regex

**M7 Analysis Insights:**
```
Top Failures:
1. Ranges (2-3, 1-2, etc.) - 27% of failures
2. Parentheticals (1 can (14.5 oz)) - 18% of failures
3. Qualifiers (minced, diced, chopped) - 15% of failures
4. Compound units (to taste, as needed) - 12% of failures
5. Descriptive (juice of 1 lemon) - 10% of failures
...
```

**M8.0 Decision:**
- Target top 5 patterns (82% of failures)
- Use Apple NLP for complex cases
- Keep regex for simple cases (performance)

---

## Goals & Success Criteria

### Functional Goals

**FG-1: Telemetry Analysis**
- Parse M7 telemetry file (parsing-failures.json)
- Identify top 10 failure patterns
- Categorize by complexity (regex-fixable vs NLP-needed)
- Document findings in analysis report

**FG-2: Hybrid Parser Architecture**
- Fast path: Regex for common patterns (< 0.03s)
- Smart path: Apple NLP for complex patterns (< 0.2s)
- Confidence thresholds determine routing
- Graceful fallback to manual edit

**FG-3: Top Pattern Support**
- Range patterns: "2-3 cloves" → 2.5 cloves
- Parenthetical units: "1 can (14.5 oz)" → 14.5 oz, can
- Qualifier extraction: "garlic, minced" → garlic (notes: minced)
- Compound phrases: "to taste" → non-parseable (confidence 0.8)
- Descriptive amounts: "juice of 1 lemon" → 1 lemon (notes: juice of)

### Non-Functional Goals

**NFG-1: Performance Maintained**
- 80% of inputs: < 0.05s (regex fast path)
- 15% of inputs: < 0.2s (NLP smart path)
- 5% of inputs: Manual edit (user-initiated)
- Overall p95 latency: < 0.3s

**NFG-2: Accuracy Improvement**
- Parsing accuracy: 95% → 98%+
- Low-confidence rate: 5% → 2%
- User edit rate: 5% → 2%
- Zero regressions on existing patterns

**NFG-3: Future-Ready Architecture**
- Parser abstraction allows ML replacement (M9.5)
- Telemetry continues to collect edge cases
- Easy to add new patterns as discovered

### Success Criteria

**Must Have (P0):**
- [ ] Telemetry analysis report complete
- [ ] Top 10 failure patterns identified
- [ ] Hybrid parser architecture implemented
- [ ] Apple NLP integration working
- [ ] Range patterns parse correctly
- [ ] Parenthetical units parse correctly
- [ ] Parsing accuracy ≥ 98%
- [ ] Performance targets met
- [ ] Zero regressions

**Should Have (P1):**
- [ ] Qualifier extraction functional
- [ ] Compound phrases handled
- [ ] Descriptive amounts supported
- [ ] Confidence calibration accurate
- [ ] Telemetry shows improvement
- [ ] Actual time: 8-12 hours

**Nice to Have (P2):**
- [ ] Parser benchmarking suite
- [ ] A/B testing framework
- [ ] Pattern suggestion system
- [ ] Auto-correction with user approval

---

## Phase Breakdown

### Phase 1: Telemetry Analysis (2 hours)

**M8.0.1: Data Collection & Parsing** (1 hour)

*Goal*: Extract insights from M7 telemetry

*Implementation*:
```swift
struct TelemetryAnalyzer {
    func analyzeFailures(from fileURL: URL) -> AnalysisReport {
        guard let data = try? Data(contentsOf: fileURL),
              let failures = try? JSONDecoder().decode([ParsingFailure].self, from: data) else {
            return AnalysisReport.empty
        }
        
        // Group by pattern
        let patterns = Dictionary(grouping: failures) { failure in
            identifyPattern(failure.originalText)
        }
        
        // Calculate frequencies
        let ranked = patterns.map { pattern, failures in
            PatternAnalysis(
                pattern: pattern,
                count: failures.count,
                percentage: Double(failures.count) / Double(failures.count) * 100,
                examples: Array(failures.prefix(5)),
                userEditRate: failures.filter(\.wasManuallyEdited).count
            )
        }.sorted { $0.count > $1.count }
        
        return AnalysisReport(
            totalFailures: failures.count,
            uniquePatterns: patterns.count,
            topPatterns: ranked.prefix(10),
            editRate: Double(failures.filter(\.wasManuallyEdited).count) / Double(failures.count)
        )
    }
    
    private func identifyPattern(_ text: String) -> String {
        // Pattern detection logic
        if text.contains("-") && text.contains(CharacterSet.decimalDigits) {
            return "range"
        } else if text.contains("(") && text.contains(")") {
            return "parenthetical"
        } else if text.hasSuffix(", minced") || text.hasSuffix(", diced") {
            return "qualifier"
        } else if text.contains("to taste") || text.contains("as needed") {
            return "compound_phrase"
        } else if text.hasPrefix("juice of") || text.hasPrefix("zest of") {
            return "descriptive"
        } else {
            return "other"
        }
    }
}
```

*Output*: Analysis report showing top patterns with examples

---

**M8.0.2: Pattern Prioritization** (1 hour)

*Goal*: Decide which patterns to target in M8.0

*Analysis Criteria*:
- **Frequency**: How often does this pattern appear?
- **User Impact**: Do users actually edit it?
- **Complexity**: Can regex handle it, or need NLP?
- **ROI**: Effort to implement vs impact

*Decision Matrix*:
```
Pattern           | Freq | Edit% | Complexity | Priority
------------------|------|-------|------------|----------
Ranges            | 27%  | 85%   | Medium     | HIGH
Parentheticals    | 18%  | 75%   | Low        | HIGH
Qualifiers        | 15%  | 40%   | Low        | MEDIUM
Compound phrases  | 12%  | 20%   | High       | MEDIUM
Descriptive       | 10%  | 60%   | High       | MEDIUM
```

*Output*: 
- Top 5 patterns for M8.0 implementation
- 5+ patterns deferred to M9.5 (ML)

*Files Created*:
- `docs/m8-docs/telemetry-analysis-report.md`
- `docs/m8-docs/pattern-prioritization.md`

---

### Phase 2: Hybrid NLP System (4-6 hours)

**M8.0.3: Parser Architecture Refactor** (1.5 hours)

*Goal*: Create abstraction that supports multiple parsing strategies

*Implementation*:
```swift
protocol IngredientParser {
    func parse(text: String) -> StructuredQuantity
}

class HybridIngredientParser: IngredientParser {
    private let regexParser: RegexIngredientParser
    private let nlpParser: NLPIngredientParser
    
    func parse(text: String) -> StructuredQuantity {
        // Fast path: Try regex first
        let regexResult = regexParser.parse(text: text)
        
        // If high confidence, return immediately
        if regexResult.parseConfidence >= 0.8 {
            return regexResult
        }
        
        // Smart path: Use NLP for complex cases
        let nlpResult = nlpParser.parse(text: text)
        
        // Return higher confidence result
        return nlpResult.parseConfidence > regexResult.parseConfidence 
            ? nlpResult 
            : regexResult
    }
}
```

*Files Modified*:
- `Services/IngredientParsingService.swift` (refactor to use protocol)
- Create `Services/Parsers/RegexIngredientParser.swift` (extract existing logic)
- Create `Services/Parsers/HybridIngredientParser.swift` (new)

*Testing*:
- Verify existing high-confidence inputs unchanged
- Verify low-confidence inputs routed to NLP
- Verify performance (fast path still < 0.05s)

---

**M8.0.4: Apple NLP Integration** (2-3 hours)

*Goal*: Use Natural Language framework for complex parsing

*Implementation*:
```swift
import NaturalLanguage

class NLPIngredientParser: IngredientParser {
    private let tagger = NLTagger(tagSchemes: [.lexicalClass, .lemma])
    
    func parse(text: String) -> StructuredQuantity {
        tagger.string = text
        
        var numbers: [Double] = []
        var units: [String] = []
        var ingredients: [String] = []
        var notes: [String] = []
        
        // Tag parts of speech
        tagger.enumerateTags(
            in: text.startIndex..<text.endIndex,
            unit: .word,
            scheme: .lexicalClass
        ) { tag, tokenRange in
            let token = String(text[tokenRange])
            
            switch tag {
            case .number:
                if let num = parseNumericValue(token) {
                    numbers.append(num)
                }
            case .noun:
                if isKnownUnit(token) {
                    units.append(token)
                } else {
                    ingredients.append(token)
                }
            case .adjective, .verb:
                // Likely qualifier: "minced", "diced"
                notes.append(token)
            default:
                break
            }
            
            return true
        }
        
        // Build structured quantity
        return buildFromComponents(
            numbers: numbers,
            units: units,
            ingredients: ingredients,
            notes: notes,
            originalText: text
        )
    }
    
    private func buildFromComponents(...) -> StructuredQuantity {
        // Construct StructuredQuantity from NLP-extracted components
        // Handle ranges, parentheticals, qualifiers
        // Return with appropriate confidence score
    }
}
```

*Key Features*:
- Uses Apple's NL tagger for part-of-speech analysis
- Separates numbers, units, ingredient names, qualifiers
- Handles complex cases regex can't
- Still fast (< 0.2s for most inputs)

*Files Created*:
- `Services/Parsers/NLPIngredientParser.swift` (~200 lines)

*Testing*:
- Test with top 10 failure patterns from telemetry
- Verify accuracy improvement (95% → 98%+)
- Verify performance (< 0.2s p95)
- Verify graceful degradation

---

**M8.0.5: Pattern-Specific Handlers** (1-1.5 hours)

*Goal*: Handle top patterns with specialized logic

*Implementation*:
```swift
// Range pattern handler
func parseRange(_ text: String) -> StructuredQuantity? {
    // "2-3 cloves" → avg(2, 3) = 2.5 cloves
    let rangePattern = #"(\d+(?:\.\d+)?)\s*-\s*(\d+(?:\.\d+)?)\s*(.+)"#
    guard let match = matchRegex(rangePattern, in: text) else { return nil }
    
    let min = Double(match[1])!
    let max = Double(match[2])!
    let average = (min + max) / 2.0
    let remainder = match[3]
    
    // Parse remainder for unit + ingredient
    let (unit, ingredient) = extractUnitAndIngredient(remainder)
    
    return StructuredQuantity(
        numericValue: average,
        standardUnit: unit,
        displayText: text,  // Preserve original
        isParseable: true,
        parseConfidence: 0.9  // High confidence for ranges
    )
}

// Parenthetical pattern handler
func parseParenthetical(_ text: String) -> StructuredQuantity? {
    // "1 can (14.5 oz) tomatoes" → 14.5 oz, tomatoes
    let parenPattern = #"(.+?)\s*\(([^)]+)\)\s*(.+)"#
    guard let match = matchRegex(parenPattern, in: text) else { return nil }
    
    let before = match[1]  // "1 can"
    let inside = match[2]  // "14.5 oz"
    let after = match[3]   // "tomatoes"
    
    // Try parsing the parenthetical as quantity+unit
    if let structured = parseSimple(inside) {
        return StructuredQuantity(
            numericValue: structured.numericValue,
            standardUnit: structured.standardUnit,
            displayText: text,
            isParseable: true,
            parseConfidence: 0.85
        )
    }
    
    return nil
}

// Qualifier pattern handler
func parseQualifier(_ text: String) -> StructuredQuantity? {
    // "2 cloves garlic, minced" → 2 cloves garlic (notes: minced)
    let qualifierPattern = #"(.+?),\s*(\w+)$"#
    guard let match = matchRegex(qualifierPattern, in: text) else { return nil }
    
    let mainPart = match[1]  // "2 cloves garlic"
    let qualifier = match[2]  // "minced"
    
    // Parse main part normally
    var structured = parseSimple(mainPart)
    structured.notes = qualifier
    
    return structured
}
```

*Files Modified*:
- `Services/Parsers/NLPIngredientParser.swift` (add pattern handlers)

*Testing*:
- Test each pattern handler with telemetry examples
- Verify edge cases handled
- Verify confidence scores appropriate

---

### Phase 3: User Correction Enhancement (2 hours)

**M8.0.6: Smart Pre-fill** (1 hour)

*Goal*: Use NLP results to pre-fill edit sheet more accurately

*Implementation*:
```swift
// In EditIngredientSheet
func loadSmartDefaults(from originalText: String) {
    // Try NLP parsing for better pre-fill
    let nlpResult = nlpParser.parse(text: originalText)
    
    if nlpResult.parseConfidence >= 0.5 {
        // Use NLP-extracted values
        quantityText = nlpResult.numericValue.map { String($0) } ?? ""
        unitText = nlpResult.standardUnit ?? ""
        nameText = nlpResult.ingredientName ?? ""
        notes = nlpResult.notes ?? ""
    } else {
        // Fall back to regex
        let regexResult = regexParser.parse(text: originalText)
        quantityText = regexResult.numericValue.map { String($0) } ?? ""
        unitText = regexResult.standardUnit ?? ""
        nameText = regexResult.ingredientName ?? ""
    }
}
```

*Files Modified*:
- `Views/Shared/EditIngredientSheet.swift`

*Testing*:
- Open edit sheet for complex ingredient
- Verify pre-filled values more accurate than M7.5
- Verify user can still override

---

**M8.0.7: Telemetry Enhancement** (1 hour)

*Goal*: Track which parser was used and performance

*Enhanced Telemetry*:
```swift
struct ParsingAttempt: Codable {
    let timestamp: Date
    let originalText: String
    let regexConfidence: Float
    let nlpConfidence: Float
    let selectedParser: String  // "regex" or "nlp"
    let finalConfidence: Float
    let parseDuration: TimeInterval
    let wasManuallyEdited: Bool
}
```

*Files Modified*:
- `Services/ParsingTelemetryService.swift`
- `Services/Parsers/HybridIngredientParser.swift` (log attempts)

*Purpose*:
- Measure performance of each parser
- Track accuracy improvement over time
- Identify patterns where NLP helps most
- Data for M9.5 ML training

---

### Phase 4: Integration Testing (2-4 hours)

**M8.0.8: Regression Testing** (1 hour)

*Goal*: Verify all M1-M7 patterns still work

*Test Suite*:
```swift
class ParsingRegressionTests: XCTestCase {
    func testHighConfidenceUnchanged() {
        // All these should still parse with high confidence
        let tests = [
            "2 cups flour",
            "1 1/2 tbsp olive oil",
            "3 eggs",
            "1/4 tsp salt"
        ]
        
        for text in tests {
            let result = parser.parse(text: text)
            XCTAssertGreaterThan(result.parseConfidence, 0.9)
            XCTAssertNotNil(result.numericValue)
        }
    }
    
    func testPerformanceRegression() {
        // Fast path should still be fast
        measure {
            _ = parser.parse(text: "2 cups flour")
        }
        // Should be < 0.05s
    }
}
```

---

**M8.0.9: Improvement Validation** (1 hour)

*Goal*: Verify top patterns from telemetry now work

*Test Suite*:
```swift
class ParsingImprovementTests: XCTestCase {
    func testRangePatterns() {
        let tests = [
            ("2-3 cloves garlic", 2.5, "clove"),
            ("1-2 cups milk", 1.5, "cup"),
            ("4-6 oz cheese", 5.0, "oz")
        ]
        
        for (text, expectedValue, expectedUnit) in tests {
            let result = parser.parse(text: text)
            XCTAssertEqual(result.numericValue, expectedValue, accuracy: 0.1)
            XCTAssert(result.standardUnit?.contains(expectedUnit) ?? false)
            XCTAssertGreaterThan(result.parseConfidence, 0.8)
        }
    }
    
    func testParentheticalPatterns() {
        // Test patterns like "1 can (14.5 oz) tomatoes"
    }
    
    func testQualifierPatterns() {
        // Test patterns like "garlic, minced"
    }
}
```

---

**M8.0.10: Performance Validation** (1-2 hours)

*Goal*: Verify performance targets met

*Benchmarking*:
```swift
class ParsingPerformanceTests: XCTestCase {
    func testFastPathPerformance() {
        // 80% of inputs should be < 0.05s
        let simpleInputs = loadSimpleInputs()  // 100 examples
        
        measure {
            for input in simpleInputs {
                _ = parser.parse(text: input)
            }
        }
        
        // Average should be < 0.05s per input
    }
    
    func testSmartPathPerformance() {
        // 15% of inputs can be < 0.2s
        let complexInputs = loadComplexInputs()  // 20 examples
        
        measure {
            for input in complexInputs {
                _ = parser.parse(text: input)
            }
        }
        
        // Average should be < 0.2s per input
    }
    
    func testP95Latency() {
        // 95th percentile should be < 0.3s
        let allInputs = loadAllInputs()  // 500 examples
        
        let durations = allInputs.map { input in
            let start = CFAbsoluteTimeGetCurrent()
            _ = parser.parse(text: input)
            return CFAbsoluteTimeGetCurrent() - start
        }.sorted()
        
        let p95Index = Int(Double(durations.count) * 0.95)
        let p95Latency = durations[p95Index]
        
        XCTAssertLessThan(p95Latency, 0.3)
    }
}
```

*Files Created*:
- `foragerTests/ParsingRegressionTests.swift`
- `foragerTests/ParsingImprovementTests.swift`
- `foragerTests/ParsingPerformanceTests.swift`
- `TestData/parsing-test-inputs.json`

---

## Technical Requirements

### TR-1: Parser Abstraction

**Requirement**: New parser is swappable (allows M9.5 ML replacement)

**Implementation**:
```swift
protocol IngredientParser {
    func parse(text: String) -> StructuredQuantity
}

// Easy to add ML parser later:
class MLIngredientParser: IngredientParser {
    func parse(text: String) -> StructuredQuantity {
        // Use CoreML model
    }
}
```

### TR-2: Performance Budgets

**Requirement**: p50, p95, p99 latencies all within targets

**Validation**:
```swift
p50 (median): < 0.05s  (fast path dominates)
p95: < 0.2s            (some NLP usage)
p99: < 0.5s            (complex NLP cases)
```

### TR-3: Accuracy Metrics

**Requirement**: Measurable improvement on telemetry data

**Validation**:
```swift
// Re-parse M7 failures with M8.0 parser
let m7Failures = loadM7Telemetry()
let m8Results = m7Failures.map { parser.parse(text: $0.originalText) }

// Calculate improvement
let m8HighConfidence = m8Results.filter { $0.parseConfidence >= 0.8 }.count
let improvementRate = Double(m8HighConfidence) / Double(m7Failures.count)

XCTAssertGreaterThan(improvementRate, 0.80)  // 80%+ of failures fixed
```

---

## Risk Management

### Technical Risks

**Risk 1: Apple NLP not accurate enough**
- *Likelihood*: Medium
- *Mitigation*: Pattern-specific handlers as fallback
- *Validation*: Test on telemetry data early (M8.0.4)

**Risk 2: Performance degradation**
- *Likelihood*: Low
- *Mitigation*: Fast path for 80% of inputs unchanged
- *Validation*: Comprehensive benchmarking (M8.0.10)

**Risk 3: Time overrun (> 12 hours)**
- *Likelihood*: Medium
- *Mitigation*: P2 features (suggestions, A/B testing) are optional
- *Validation*: Track time per phase, cut scope if needed

### UX Risks

**Risk 1: Users don't notice improvement**
- *Likelihood*: Medium
- *Mitigation*: Highlight in release notes, show "Improved" badge
- *Validation*: Telemetry shows reduced edit rate

**Risk 2: Confidence scores miscalibrated**
- *Likelihood*: Medium
- *Mitigation*: Extensive testing on telemetry data
- *Validation*: User feedback during M8.1+ external beta

---

## Timeline & Estimation

### Phase-by-Phase Estimates

| Phase | Tasks | Time Estimate |
|-------|-------|---------------|
| **Phase 1** | Telemetry Analysis | **2 hours** |
| M8.0.1 | Data collection & parsing | 1 hour |
| M8.0.2 | Pattern prioritization | 1 hour |
| **Phase 2** | Hybrid NLP System | **4-6 hours** |
| M8.0.3 | Parser architecture refactor | 1.5 hours |
| M8.0.4 | Apple NLP integration | 2-3 hours |
| M8.0.5 | Pattern-specific handlers | 1-1.5 hours |
| **Phase 3** | User Correction Enhancement | **2 hours** |
| M8.0.6 | Smart pre-fill | 1 hour |
| M8.0.7 | Telemetry enhancement | 1 hour |
| **Phase 4** | Integration Testing | **2-4 hours** |
| M8.0.8 | Regression testing | 1 hour |
| M8.0.9 | Improvement validation | 1 hour |
| M8.0.10 | Performance validation | 1-2 hours |

**Total**: 10-14 hours (targeting 8-12 hour range)

**Dependencies**: M7.6 complete, 2+ weeks of telemetry data

---

## Integration Points

### Dependencies

**From M7.6 (External TestFlight):**
- 10+ external beta testers active
- 2-4 weeks of telemetry data collected
- User feedback on parsing quality
- Real-world usage patterns identified

**To M8.1 (Analytics Infrastructure):**
- Improved parsing enables better analytics
- Clean data = more accurate insights
- Foundation for ingredient frequency analysis

**To M9.5 (ML-Powered Parsing):**
- Telemetry from M8.0 = training data
- Parser abstraction makes ML integration easy
- User corrections guide model training

---

## Future Vision

### M8.1-8.4: Analytics Dashboard
- Leverage improved parsing for ingredient analytics
- Show parsing accuracy trends over time
- Track which patterns users encounter most

### M9.5: ML-Powered Parsing (Optional)
- Train Create ML model on 100+ corrections
- Replace NLP parser with ML parser
- On-device inference for privacy
- Self-improving system

**M8.0 provides the data and architecture** for M9.5 ML evolution.

---

## Post-Milestone Documentation

### After M8.0 Completion

**Required Documentation Updates:**
1. **Learning Note**: Create `docs/learning-notes/26-m8.0-parsing-improvements.md`
   - Document telemetry analysis findings
   - Share NLP integration architecture
   - Note accuracy improvement metrics
   - Record performance benchmarks

2. **Analysis Report**: Create `docs/m8-docs/telemetry-analysis-report.md`
   - Top 10 failure patterns
   - Pattern prioritization matrix
   - ROI analysis

3. **Update current-story.md**: Mark M8.0 complete with actual hours

4. **Update roadmap.md**: Update M8.0 status, reference learning note

5. **Git Commit**: "M8.0 COMPLETE: Hybrid NLP parsing, 98%+ accuracy achieved"

---

## Acceptance Criteria

### Must Have (P0) - Blocking M8.1

- [ ] Telemetry analysis report complete
- [ ] Top 10 failure patterns identified
- [ ] Hybrid parser architecture implemented
- [ ] Apple NLP framework integrated
- [ ] Range patterns parse correctly (≥90% accuracy)
- [ ] Parenthetical patterns parse correctly (≥85% accuracy)
- [ ] Overall parsing accuracy ≥ 98%
- [ ] Low-confidence rate ≤ 2%
- [ ] Performance: p95 latency < 0.3s
- [ ] Zero regressions on M7 patterns
- [ ] All tests passing
- [ ] Build succeeds with no warnings

### Should Have (P1) - Strong preference

- [ ] Qualifier patterns handled (≥70% accuracy)
- [ ] Compound phrases recognized
- [ ] Descriptive amounts parsed
- [ ] Confidence scores calibrated
- [ ] Telemetry shows improvement
- [ ] Documentation complete
- [ ] Actual time: 8-12 hours

### Nice to Have (P2) - Future enhancement

- [ ] Parser benchmarking dashboard
- [ ] A/B testing framework
- [ ] Pattern suggestion system
- [ ] Auto-correction with approval

---

## Getting Started

### Pre-Development Checklist

**Before M8.0.1:**
- [ ] Read session-startup-checklist.md
- [ ] Read project-naming-standards.md
- [ ] Read current-story.md
- [ ] Read M8.0 PRD (this document) completely
- [ ] Verify M7 completely finished
- [ ] Have ≥2 weeks of M7 telemetry data
- [ ] Reviewed M7 external beta feedback

### First Session Start Prompt

```
I'm ready to start M8.0 - Parsing Improvements Foundation.

I've completed:
✅ session-startup-checklist.md
✅ project-naming-standards.md
✅ current-story.md
✅ M8.0 PRD review
✅ M7 validation complete
✅ Telemetry data collected (2+ weeks)

Let's start with M8.0.1: Telemetry Analysis.

Current state:
- M7.6 external beta launched
- 10+ external testers active
- parsing-failures.json contains real usage data
- M7.5 graceful degradation working

First task: Parse telemetry file, identify top 10 failure patterns,
create analysis report with examples and frequency data.
```

---

**Version**: 1.0  
**Status**: ⏳ PLANNED  
**Estimated**: 8-12 hours  
**Dependencies**: M7 complete with ≥2 weeks telemetry  
**Next Milestone**: M8.1 Analytics Infrastructure
